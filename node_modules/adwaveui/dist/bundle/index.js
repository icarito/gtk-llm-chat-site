var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// node_modules/jsxte/dist/esm/jsx/jsx-runtime.mjs
(() => {
  if (typeof Symbol.toHtmlTag === "symbol")
    return;
  Object.defineProperty(Symbol, "toHtmlTag", {
    value: Symbol("toHtmlTag"),
    enumerable: false,
    configurable: true
  });
})();
var mapChildren = /* @__PURE__ */ __name((children, accumulator) => {
  switch (typeof children) {
    case "string":
      accumulator.push({ type: "textNode", text: children });
      break;
    case "number":
      accumulator.push({ type: "textNode", text: children.toString() });
      break;
    case "object":
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          mapChildren(child, accumulator);
        }
      } else if (children != null) {
        if (Symbol.toHtmlTag in children && typeof children[Symbol.toHtmlTag] === "function") {
          const html = String(children[Symbol.toHtmlTag]());
          accumulator.push({ type: "textNode", text: html });
        } else {
          accumulator.push(children);
        }
      }
      break;
  }
  return accumulator;
}, "mapChildren");
var createElement = /* @__PURE__ */ __name((tag, props, ...children) => {
  props ?? (props = {});
  const finalChildren = [];
  for (let i = 0; i < children.length; i++) {
    mapChildren(children[i], finalChildren);
  }
  if (props?.children) {
    mapChildren(props.children, finalChildren);
  }
  props.children = finalChildren;
  Object.freeze(finalChildren);
  Object.freeze(props);
  return {
    type: "tag",
    // @ts-expect-error
    tag,
    props
  };
}, "createElement");
var jsx = createElement;
var jsxs = jsx;
var Fragment = "";

// node_modules/adwavecss/dist/index.js
var Theme = class _Theme {
  static {
    __name(this, "Theme");
  }
  static dark = "dark-theme";
  static light = "light-theme";
  static light2 = "light-theme-2";
  static className(params) {
    switch (params.type) {
      case "light":
        return _Theme.light;
      case "light2":
        return _Theme.light2;
    }
    return _Theme.dark;
  }
};
var Box = class _Box {
  static {
    __name(this, "Box");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/box.md#ClassNames
   */
  static box = "box";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/box.md#ClassNames
   */
  static rounded = "rounded";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/box.md#ClassNames
   */
  static bg2 = "bg-level-2";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/box.md#ClassNames
   */
  static bg3 = "bg-level-3";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/box.md#ClassNames
   */
  static bg4 = "bg-level-4";
  static className(params) {
    let className = _Box.box;
    if (params.rounded) {
      className += ` ${_Box.rounded}`;
    }
    if (params.bg) {
      switch (params.bg) {
        case 4:
          className += ` ${_Box.bg4}`;
          break;
        case 3:
          className += ` ${_Box.bg3}`;
          break;
        case 2:
          className += ` ${_Box.bg2}`;
          break;
      }
    }
    return className;
  }
};
var Button = class _Button {
  static {
    __name(this, "Button");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static button = "btn";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static disabled = "disabled";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static primary = "primary";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static danger = "danger";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static flat = "flat";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static pill = "pill";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static circular = "circular";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static square = "square";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static toggled = "toggled";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static wrapper = "btn-wrapper";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/button.md#ClassNames
   */
  static adaptive = "adaptive";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/linked.md
   */
  static linked = "linked";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/linked.md
   */
  static linkedVertical = "vertical";
  static className(params) {
    let className = _Button.button;
    if (params.disabled) {
      className += ` ${_Button.disabled}`;
    }
    if (params.color) {
      switch (params.color) {
        case "primary":
          className += ` ${_Button.primary}`;
          break;
        case "danger":
          className += ` ${_Button.danger}`;
          break;
      }
    }
    if (params.shape) {
      switch (params.shape) {
        case "circular":
          className += ` ${_Button.circular}`;
          break;
        case "square":
          className += ` ${_Button.square}`;
          break;
      }
    }
    if (params.flat) {
      className += ` ${_Button.flat}`;
    }
    if (params.pill) {
      className += ` ${_Button.pill}`;
    }
    if (params.toggled) {
      className += ` ${_Button.toggled}`;
    }
    if (params.adaptive) {
      className += ` ${_Button.adaptive}`;
    }
    if (params.linked) {
      className += ` ${_Button.linked}`;
    }
    if (params.linkedVertical) {
      className += ` ${_Button.linkedVertical}`;
    }
    return className;
  }
};
var Card = class _Card {
  static {
    __name(this, "Card");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/card.md#ClassNames
   */
  static card = "card";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/card.md#ClassNames
   */
  static activable = "activable";
  static className(params) {
    let className = _Card.card;
    if (params.activable) {
      className += ` ${_Card.activable}`;
    }
    return className;
  }
};
var Checkbox = class _Checkbox {
  static {
    __name(this, "Checkbox");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/checkbox.md#ClassNames
   */
  static checkbox = "checkbox";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/checkbox.md#ClassNames
   */
  static disabled = "disabled";
  static className(params) {
    let className = _Checkbox.checkbox;
    if (params.disabled) {
      className += ` ${_Checkbox.disabled}`;
    }
    return className;
  }
};
var Frame = class _Frame {
  static {
    __name(this, "Frame");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/frame.md#ClassNames
   */
  static frame = "frame";
  static className() {
    return _Frame.frame;
  }
};
var Input = class _Input {
  static {
    __name(this, "Input");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/input.md#ClassNames
   */
  static input = "input";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/input.md#ClassNames
   */
  static disabled = "disabled";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/linked.md
   */
  static linked = "linked";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/linked.md
   */
  static linkedVertical = "vertical";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/input.md#ClassNames
   */
  static wrapper = "input-wrapper";
  static className(params) {
    let className = _Input.input;
    if (params.disabled) {
      className += ` ${_Input.disabled}`;
    }
    if (params.linked) {
      className += ` ${_Input.linked}`;
    }
    if (params.linkedVertical) {
      className += ` ${_Input.linkedVertical}`;
    }
    return className;
  }
  static wrapperClassName() {
    return _Input.wrapper;
  }
};
var List = class _List {
  static {
    __name(this, "List");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/list.md#ClassNames
   */
  static list = "list";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/list.md#ClassNames
   */
  static element = "list-element";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/list.md#ClassNames
   */
  static activableElement = "activable";
  static className() {
    let className = _List.list;
    return className;
  }
  static elementClassName(params) {
    let className = _List.element;
    if (params.activable) {
      className += ` ${_List.activableElement}`;
    }
    return className;
  }
};
var Message = class _Message {
  static {
    __name(this, "Message");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/message.md#ClassNames
   */
  static message = "message";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/message.md#ClassNames
   */
  static success = "success";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/message.md#ClassNames
   */
  static alert = "alert";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/message.md#ClassNames
   */
  static error = "error";
  static className(params) {
    let className = _Message.message;
    if (params.type) {
      switch (params.type) {
        case "success":
          className += ` ${_Message.success}`;
          break;
        case "alert":
          className += ` ${_Message.alert}`;
          break;
        case "error":
          className += ` ${_Message.error}`;
          break;
      }
    }
    return className;
  }
};
var NavSidebar = class _NavSidebar {
  static {
    __name(this, "NavSidebar");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/nav-sidebar.md#ClassNames
   */
  static navSidebar = "nav-sidebar";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/nav-sidebar.md#ClassNames
   */
  static button = "nav-sidebar-btn";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/nav-sidebar.md#ClassNames
   */
  static separator = "separator";
  static active = "active";
  static className() {
    return _NavSidebar.navSidebar;
  }
  static btnClassName(params) {
    let className = _NavSidebar.button;
    if (params.active) {
      className += ` ${_NavSidebar.active}`;
    }
    return className;
  }
  static separatorClassName() {
    return _NavSidebar.separator;
  }
};
var ScrollView = class _ScrollView {
  static {
    __name(this, "ScrollView");
  }
  static scrollView = "scrollview";
  static className() {
    return _ScrollView.scrollView;
  }
};
var Selector = class _Selector {
  static {
    __name(this, "Selector");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static selector = "selector";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static disabled = "disabled";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static selectedOption = "selected-option";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static downButton = "down-button";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static opened = "opened";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static optionsList = "options-list";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static option = "option";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static top = "top";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/selector.md#ClassNames
   */
  static noPosition = "no-position";
  static className(params) {
    let className = _Selector.selector;
    if (params.disabled) {
      className += ` ${_Selector.disabled}`;
    }
    if (params.opened) {
      className += ` ${_Selector.opened}`;
    }
    if (params.noPosition) {
      className += ` ${_Selector.noPosition}`;
    }
    if (params.position === "top") {
      className += ` ${_Selector.top}`;
    }
    return className;
  }
  static optionClassName() {
    let className = _Selector.option;
    return className;
  }
  static selectedOptionClassName() {
    let className = _Selector.selectedOption;
    return className;
  }
  static listClassName() {
    let className = _Selector.optionsList;
    return className;
  }
  static downButtonClassName() {
    let className = _Selector.downButton;
    return className;
  }
};
var Separator = class _Separator {
  static {
    __name(this, "Separator");
  }
  static separator = "separator";
  static vertical = "vertical";
  static className(params) {
    let className = _Separator.separator;
    if (params.vertical) {
      className += ` ${_Separator.vertical}`;
    }
    return className;
  }
};
var Skeleton = class _Skeleton {
  static {
    __name(this, "Skeleton");
  }
  static skeleton = "skeleton";
  static className() {
    return _Skeleton.skeleton;
  }
};
var Slider = class _Slider {
  static {
    __name(this, "Slider");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/slider.md#ClassNames
   */
  static slider = "slider";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/slider.md#ClassNames
   */
  static disabled = "disabled";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/slider.md#ClassNames
   */
  static track = "slider-track";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/slider.md#ClassNames
   */
  static progress = "slider-progress";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/slider.md#ClassNames
   */
  static thumb = "slider-thumb";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/slider.md#ClassNames
   */
  static noPosition = "no-position";
  static className(params) {
    let className = _Slider.slider;
    if (params.disabled) {
      className += ` ${_Slider.disabled}`;
    }
    if (params.noPosition) {
      className += ` ${_Slider.noPosition}`;
    }
    return className;
  }
  static trackClassName() {
    let className = _Slider.track;
    return className;
  }
  static progressClassName() {
    let className = _Slider.progress;
    return className;
  }
  static thumbClassName() {
    let className = _Slider.thumb;
    return className;
  }
};
var Suggestions = class _Suggestions {
  static {
    __name(this, "Suggestions");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/suggestions.md#ClassNames
   */
  static suggestions = "suggestions";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/suggestions.md#ClassNames
   */
  static option = "suggestions-option";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/suggestions.md#ClassNames
   */
  static active = "active";
  static className() {
    let className = _Suggestions.suggestions;
    return className;
  }
  static optionClassName(params) {
    let className = _Suggestions.option;
    if (params.active) {
      className += ` ${_Suggestions.active}`;
    }
    return className;
  }
};
var Switch = class _Switch {
  static {
    __name(this, "Switch");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/switch.md#ClassNames
   */
  static switch = "switch";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/switch.md#ClassNames
   */
  static disabled = "disabled";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/switch.md#ClassNames
   */
  static knob = "switch-knob";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/switch.md#ClassNames
   */
  static active = "active";
  static className(params) {
    let className = _Switch.switch;
    if (params.disabled) {
      className += ` ${_Switch.disabled}`;
    }
    if (params.active) {
      className += ` ${_Switch.active}`;
    }
    return className;
  }
};
var Typography = class _Typography {
  static {
    __name(this, "Typography");
  }
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/typography.md#ClassNames
   */
  static text = "text";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/typography.md#ClassNames
   */
  static subtitle = "subtitle";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/typography.md#ClassNames
   */
  static label = "label";
  /**
   * Read more at @link https://github.com/ncpa0/ADWaveCSS/blob/master/docs/components/typography.md#ClassNames
   */
  static header = "header";
  static className(params) {
    switch (params.type) {
      case "subtitle":
        return _Typography.subtitle;
      case "label":
        return _Typography.label;
      case "header":
        return _Typography.header;
    }
    return _Typography.text;
  }
};
Object.freeze(Box);
Object.freeze(Button);
Object.freeze(Card);
Object.freeze(Checkbox);
Object.freeze(Frame);
Object.freeze(Input);
Object.freeze(List);
Object.freeze(Message);
Object.freeze(NavSidebar);
Object.freeze(ScrollView);
Object.freeze(Selector);
Object.freeze(Separator);
Object.freeze(Skeleton);
Object.freeze(Slider);
Object.freeze(Suggestions);
Object.freeze(Switch);
Object.freeze(Theme);
Object.freeze(Typography);

// node_modules/jsxte/dist/esm/utilities/array-flat-polyfill.mjs
function flat(depth) {
  const copy = [];
  if (depth === void 0) {
    depth = 1;
  }
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (depth > 0 && Array.isArray(item)) {
      const itemFlatCopy = flat.call(item, depth - 1);
      for (let j = 0; j < itemFlatCopy.length; j++) {
        copy.push(itemFlatCopy[j]);
      }
    } else {
      copy.push(item);
    }
  }
  return copy;
}
__name(flat, "flat");
if (!Array.prototype.flat) {
  Object.defineProperty(Array.prototype, "flat", {
    configurable: true,
    value: flat,
    writable: true
  });
}

// node_modules/jsxte/dist/esm/jsxte-render-error.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField = /* @__PURE__ */ __name((obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
}, "__publicField");
var mapReverse = /* @__PURE__ */ __name((arr, fn) => {
  const result = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    result.push(fn(arr[i]));
  }
  return result;
}, "mapReverse");
var JsxteRenderError = class _JsxteRenderError extends Error {
  static {
    __name(this, "_JsxteRenderError");
  }
  constructor(message, insideTag, causedBy) {
    super(message, { cause: causedBy });
    __publicField(this, "baseMessage", "");
    __publicField(this, "parentTags", []);
    this.name = "JsxteRenderError";
    this.baseMessage = message;
    if (insideTag) {
      this.parentTags.push(insideTag);
    }
    if (this.cause == null) {
      Object.defineProperty(this, "cause", {
        value: causedBy,
        enumerable: true,
        writable: true
      });
    }
  }
  static is(err) {
    return err instanceof _JsxteRenderError;
  }
  /**
   * @internal
   */
  pushParent(tag) {
    this.parentTags.push(tag);
  }
  /**
   * @internal
   */
  regenerateMessage() {
    this.message = `The below error has occurred in:
${mapReverse(
      this.parentTags.filter((t) => t !== ""),
      (tag) => `<${tag}>`
    ).join("\n")}

${this.baseMessage}`;
  }
};

// node_modules/jsxte/dist/esm/dom-renderer/dom-renderer.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
}, "__publicField");
var DomRenderer = class {
  static {
    __name(this, "DomRenderer");
  }
  constructor(window2, options = {}) {
    this.window = window2;
    this.options = options;
    __publicField2(this, "generator");
    __publicField2(this, "setAttribute", (element, name, value) => {
      if (typeof value === "boolean") {
        if (value) {
          value = name;
        } else {
          return;
        }
      }
      element.setAttribute(name, value);
    });
    if (options.attributeSetter) {
      this.setAttribute = options.attributeSetter;
    }
    const doc = this.window.document;
    const domrenderer = this;
    class DomGenerator {
      static {
        __name(this, "DomGenerator");
      }
      createElement(type, attributes, children) {
        const element = doc.createElement(type);
        for (const [name, value] of attributes) {
          domrenderer.setAttribute(element, name, value);
        }
        for (const child of children) {
          element.appendChild(child);
        }
        return element;
      }
      createTextNode(text) {
        return doc.createTextNode(String(text));
      }
      createFragment(children) {
        const fragment = doc.createDocumentFragment();
        for (const child of children) {
          fragment.appendChild(child);
        }
        return fragment;
      }
    }
    this.generator = new DomGenerator();
  }
  render(component, componentApi) {
    const renderer = new JsxteRenderer(this.generator, {
      ...this.options,
      allowAsync: false
    }, componentApi);
    return renderer.render(component);
  }
  async renderAsync(component, componentApi) {
    const renderer = new JsxteRenderer(this.generator, {
      ...this.options,
      allowAsync: true
    }, componentApi);
    return renderer.render(component);
  }
};

// node_modules/jsxte/dist/esm/utilities/join.mjs
function join(arr, separator = "\n") {
  let result = arr[0] ?? "";
  const until = arr.length;
  for (let i = 1; i < until; i++) {
    result += separator + arr[i];
  }
  return result;
}
__name(join, "join");

// node_modules/jsxte/dist/esm/html-renderer/attribute-to-html-tag-string.mjs
var attributeToHtmlTagString = /* @__PURE__ */ __name(([key, value]) => {
  if (value === true) {
    return `${key}`;
  }
  if (value === false || value === null || value === void 0) {
    return "";
  }
  return `${key}="${value.toString().replace(/"/g, "&quot;")}"`;
}, "attributeToHtmlTagString");
var mapAttributesToHtmlTagString = /* @__PURE__ */ __name((attributes) => {
  const results = [];
  for (let i = 0; i < attributes.length; i++) {
    const attribute = attributes[i];
    const html = attributeToHtmlTagString(attribute);
    if (html.length > 0)
      results.push(html);
  }
  return join(results, " ");
}, "mapAttributesToHtmlTagString");

// node_modules/jsxte/dist/esm/utilities/self-closing-tag-list.mjs
var SELF_CLOSING_TAG_LIST = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// node_modules/jsxte/dist/esm/html-renderer/base-html-generator.mjs
var BaseHtmlGenerator = class _BaseHtmlGenerator {
  static {
    __name(this, "_BaseHtmlGenerator");
  }
  constructor(options) {
    this.options = options;
  }
  generateTagCompact(tag, attributes, content) {
    if (attributes) {
      attributes = " " + attributes;
    } else {
      attributes = "";
    }
    if (!content || content.length === 0) {
      if (SELF_CLOSING_TAG_LIST.includes(tag)) {
        return `<${tag}${attributes} />`;
      } else {
        return `<${tag}${attributes}></${tag}>`;
      }
    }
    return `<${tag}${attributes}>${content}</${tag}>`;
  }
  flattenChildrenCompact(children) {
    return join(children, "");
  }
  generateTag(tag, attributes, content) {
    if (attributes) {
      attributes = " " + attributes;
    } else {
      attributes = "";
    }
    if (!content || content.length === 0) {
      if (SELF_CLOSING_TAG_LIST.includes(tag)) {
        return [{
          type: "tag-selfclose",
          tag,
          content: `<${tag}${attributes} />`
        }];
      } else {
        return [{
          type: "tag-inline",
          tag,
          content: `<${tag}${attributes}></${tag}>`
        }];
      }
    }
    return [
      {
        type: "tag-open",
        tag,
        content: `<${tag}${attributes}>`
      },
      ...content,
      {
        type: "tag-close",
        tag,
        content: `</${tag}>`
      }
    ];
  }
  flattenChildren(children) {
    const result = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.length === 1 && child[0].type === "text") {
        const last = result.at(-1);
        if (last?.type === "text") {
          last.content += child[0].content;
          continue;
        }
      }
      const lasIdx = result.length;
      for (let j = 0; j < child.length; j++) {
        result[lasIdx + j] = child[j];
      }
    }
    return result;
  }
  static leftPad(str, pad) {
    if (!str.includes("\n")) {
      return pad + str;
    } else {
      const lines = str.split("\n");
      for (let i = 0; i < lines.length; i++) {
        lines[i] = pad + lines[i];
      }
      return join(lines);
    }
  }
  static trimContent(content) {
    let leftWhitespace = 0;
    let rightWhitespace = 0;
    let wsLeft = false;
    let wsRight = false;
    for (let i = 0; i < content.length; i++) {
      if (content[i] === " " || content[i] === "\n") {
        leftWhitespace += 1;
      } else {
        break;
      }
    }
    if (leftWhitespace === content.length) {
      return { wsLeft: true, wsRight: true, trimmed: "" };
    }
    if (leftWhitespace > 0) {
      content = content.substring(leftWhitespace);
      wsLeft = true;
    }
    for (let i = content.length - 1; i >= 0; i--) {
      if (content[i] === " " || content[i] === "\n") {
        rightWhitespace += 1;
      } else {
        break;
      }
    }
    if (rightWhitespace > 0) {
      content = content.substring(0, content.length - rightWhitespace);
      wsRight = true;
    }
    return { wsLeft, wsRight, trimmed: content };
  }
  static concatHtmlLines(lines, options) {
    let result = "";
    const indentLength = options?.indent ?? 2;
    const singleIndent = " ".repeat(indentLength);
    let currentIndent = "";
    let inPre = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (inPre > 0) {
        const isLast = lines[i + 1]?.type === "tag-close" && lines[i + 1]?.tag === "pre";
        const suffix = isLast ? "" : "\n";
        switch (line.type) {
          case "tag-open":
            if (line.tag === "pre") {
              inPre += 1;
            }
            result += line.content + suffix;
            currentIndent += singleIndent;
            break;
          case "tag-close":
            if (line.tag === "pre") {
              inPre -= 1;
            }
            result += line.content + suffix;
            currentIndent = currentIndent.substring(indentLength);
            break;
          case "tag-inline":
            result += line.content + suffix;
            break;
          case "tag-selfclose":
            result += line.content + suffix;
            break;
          case "text":
            result += line.content + suffix;
            break;
        }
      } else {
        switch (line.type) {
          case "tag-open": {
            let suffix = "\n";
            if (line.tag === "pre") {
              inPre += 1;
              suffix = "";
            } else {
              const nextLine = lines[i + 1];
              const addNewLine = nextLine ? nextLine.type === "tag-open" || nextLine.type === "tag-selfclose" : true;
              if (!addNewLine) {
                suffix = "";
              } else if (result.length && result.at(-1) !== "\n") {
                result += "\n";
              }
            }
            const addIndent = result.at(-1) === "\n";
            if (addIndent) {
              result += currentIndent + line.content + suffix;
            } else {
              result += line.content + suffix;
            }
            currentIndent += singleIndent;
            break;
          }
          case "tag-close": {
            currentIndent = currentIndent.substring(indentLength);
            const nextLine = lines[i + 1];
            const addIndent = result.at(-1) === "\n";
            const addNewLine = nextLine ? nextLine.type === "tag-close" || nextLine.type === "tag-selfclose" : true;
            if (addIndent) {
              result += currentIndent;
            }
            result += line.content;
            if (addNewLine) {
              result += "\n";
            }
            break;
          }
          case "tag-inline": {
            const nextLine = lines[i + 1];
            const addIndent = result.at(-1) === "\n";
            const addNewLine = nextLine ? nextLine.type !== "text" : true;
            if (addIndent) {
              result += currentIndent;
            }
            result += line.content;
            if (addNewLine) {
              result += "\n";
            }
            break;
          }
          case "tag-selfclose": {
            result += currentIndent + line.content + "\n";
            break;
          }
          case "text": {
            const content = _BaseHtmlGenerator.trimContent(line.content);
            const nextLine = lines[i + 1];
            const addIndent = result.at(-1) === "\n";
            if (addIndent) {
              result += _BaseHtmlGenerator.leftPad(
                content.trimmed,
                currentIndent
              );
            } else {
              if (content.wsLeft && content.trimmed !== "") {
                result += "\n" + _BaseHtmlGenerator.leftPad(content.trimmed, currentIndent);
              } else {
                result += content.trimmed;
              }
            }
            if (content.wsRight && nextLine?.type !== "tag-close") {
              result += "\n";
            }
            break;
          }
        }
      }
    }
    return result;
  }
};

// node_modules/jsxte/dist/esm/html-renderer/jsx-elem-to-html-sync.mjs
var HtmlCompactGenerator = class extends BaseHtmlGenerator {
  static {
    __name(this, "HtmlCompactGenerator");
  }
  createTextNode(text) {
    return String(text);
  }
  createElement(type, attributes, children) {
    const attributesString = mapAttributesToHtmlTagString(attributes);
    const content = this.flattenChildrenCompact(children);
    return this.generateTagCompact(type, attributesString, content);
  }
  createFragment(children) {
    return this.flattenChildrenCompact(children);
  }
};
var HtmlPrettyGenerator = class extends BaseHtmlGenerator {
  static {
    __name(this, "HtmlPrettyGenerator");
  }
  createTextNode(text) {
    return [{ type: "text", content: String(text) }];
  }
  createElement(type, attributes, children) {
    const attributesString = mapAttributesToHtmlTagString(attributes);
    const content = this.flattenChildren(children);
    return this.generateTag(type, attributesString, content);
  }
  createFragment(children) {
    return this.flattenChildren(children);
  }
};
var jsxElemToHtmlSync = /* @__PURE__ */ __name((element, componentApi, options = {}) => {
  const { pretty = false } = options;
  if (pretty) {
    const renderer = new JsxteRenderer(
      new HtmlPrettyGenerator(options),
      { ...options, allowAsync: false },
      componentApi
    );
    const lines = renderer.render(element);
    return HtmlPrettyGenerator.concatHtmlLines(lines, options);
  } else {
    const renderer = new JsxteRenderer(
      new HtmlCompactGenerator(options),
      { ...options, allowAsync: false },
      componentApi
    );
    return renderer.render(element);
  }
}, "jsxElemToHtmlSync");

// node_modules/jsxte/dist/esm/json-renderer/jsx-elem-to-json.mjs
var JsonGenerator = class {
  static {
    __name(this, "JsonGenerator");
  }
  createTextNode(text) {
    return text;
  }
  createElement(type, attributes, children) {
    return {
      element: type,
      attributes,
      children
    };
  }
  createFragment(children) {
    return {
      element: "",
      attributes: [],
      children
    };
  }
};
var jsxElemToJsonSync = /* @__PURE__ */ __name((element, componentApi, options) => {
  const renderer = new JsxteRenderer(
    new JsonGenerator(),
    { ...options, allowAsync: false },
    componentApi
  );
  return renderer.render(element);
}, "jsxElemToJsonSync");
var AsyncJsonGenerator = class {
  static {
    __name(this, "AsyncJsonGenerator");
  }
  createTextNode(text) {
    return text;
  }
  async createElement(type, attributes, children) {
    return {
      element: type,
      attributes,
      children: await Promise.resolve(children).then((c) => Promise.all(c))
    };
  }
  async createFragment(children) {
    return {
      element: "",
      attributes: [],
      children: await Promise.resolve(children).then((c) => Promise.all(c))
    };
  }
};
var jsxElemToJsonAsync = /* @__PURE__ */ __name((element, componentApi, options) => {
  const renderer = new JsxteRenderer(
    new AsyncJsonGenerator(),
    { ...options, allowAsync: true },
    componentApi
  );
  return renderer.render(element);
}, "jsxElemToJsonAsync");

// node_modules/jsxte/dist/esm/component-api/component-api.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp3 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField3 = /* @__PURE__ */ __name((obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
}, "__publicField");
var ContextAccessor = class _ContextAccessor {
  static {
    __name(this, "_ContextAccessor");
  }
  constructor(map = /* @__PURE__ */ new Map()) {
    this.map = map;
  }
  static clone(original) {
    return new _ContextAccessor(new Map(original.map));
  }
  /**
   * Retrieve the context data for the specified context. If the context has
   * never been set by any of this component ancestors an error will be thrown.
   */
  getOrFail(ref) {
    const value = this.map.get(ref.id);
    if (value === void 0) {
      throw new Error(
        "Context not defined! Make sure the context is set before accessing it."
      );
    }
    return value;
  }
  /** Retrieve the context data for the specified context. */
  get(ref) {
    const value = this.map.get(ref.id);
    return value;
  }
  /**
   * Partially update the state of the context data. Works only for objects and
   * can only be used if some context data is already set beforehand.
   *
   * Updates to the context made with this method are only visible to this
   * component and it's descendants.
   */
  update(ref, updateData) {
    const data = this.get(ref);
    if (typeof data === "object" && data !== null && typeof updateData === "object" && updateData !== null) {
      if (Array.isArray(data)) {
        const arr = Array.from(data);
        const entries = Object.entries(updateData);
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          const index = Number(key);
          if (!isNaN(index))
            arr[index] = value;
        }
        return void this.map.set(ref.id, arr);
      } else {
        return void this.map.set(ref.id, { ...data, ...updateData });
      }
    } else {
      throw new Error(
        "Context data is not an object!. Partial updates are only possible for objects."
      );
    }
  }
  /**
   * Sets the context data for the specified context.
   *
   * Changes to the context made with this method are only visible to this
   * component and it's descendants.
   */
  set(ref, data) {
    this.map.set(ref.id, data);
  }
  /** Check if the context data for the specified context is set. */
  has(ref) {
    return this.map.has(ref.id);
  }
  /**
   * Replaces this context entries with the entries of the context provided.
   *
   * @internal
   */
  replace(context) {
    this.map = context.map;
  }
};
var ComponentApi = class _ComponentApi {
  static {
    __name(this, "_ComponentApi");
  }
  constructor(options, accessor) {
    this.options = options;
    __publicField3(this, "ctx");
    this.ctx = accessor ?? new ContextAccessor();
  }
  static create(options) {
    return new _ComponentApi(options);
  }
  static clone(original) {
    return new _ComponentApi(
      original.options,
      ContextAccessor.clone(original.ctx)
    );
  }
  /**
   * Renders the given JSX component to pure html as if it was a child of this
   * component. All context available to this component will be available to the
   * given component as well.
   */
  render(component, optionsOverrides) {
    const thisCopy = _ComponentApi.clone(this);
    if (optionsOverrides) {
      return jsxElemToHtmlSync(component, thisCopy, {
        ...this.options,
        ...optionsOverrides
      });
    }
    return jsxElemToHtmlSync(component, thisCopy, this.options);
  }
  async renderAsync(component, optionsOverrides) {
    const thisCopy = _ComponentApi.clone(this);
    if (optionsOverrides) {
      return Promise.resolve(component).then(
        (c) => jsxElemToHtmlAsync(c, thisCopy, {
          ...this.options,
          ...optionsOverrides
        })
      );
    }
    return Promise.resolve(component).then(
      (c) => jsxElemToHtmlAsync(c, thisCopy, this.options)
    );
  }
  renderToJson(component, optionsOverrides) {
    const thisCopy = _ComponentApi.clone(this);
    if (optionsOverrides) {
      return jsxElemToJsonSync(component, thisCopy, {
        ...this.options,
        ...optionsOverrides
      });
    }
    return jsxElemToJsonSync(component, thisCopy, this.options);
  }
  async renderToJsonAsync(component, optionsOverrides) {
    const thisCopy = _ComponentApi.clone(this);
    if (optionsOverrides) {
      return Promise.resolve(component).then(
        (c) => jsxElemToJsonAsync(c, thisCopy, {
          ...this.options,
          ...optionsOverrides
        })
      );
    }
    return Promise.resolve(component).then(
      (c) => jsxElemToJsonAsync(c, thisCopy, this.options)
    );
  }
  renderToDom(window2, component, optionsOverrides) {
    const thisCopy = _ComponentApi.clone(this);
    if (optionsOverrides) {
      const r2 = new DomRenderer(window2, {
        ...this.options,
        ...optionsOverrides
      });
      return r2.render(component, thisCopy);
    }
    const r = new DomRenderer(window2, this.options);
    return r.render(component, thisCopy);
  }
  async renderToDomAsync(window2, component, optionsOverrides) {
    const thisCopy = _ComponentApi.clone(this);
    if (optionsOverrides) {
      const r2 = new DomRenderer(window2, {
        ...this.options,
        ...optionsOverrides
      });
      return Promise.resolve(component).then((c) => r2.renderAsync(c, thisCopy));
    }
    const r = new DomRenderer(window2, this.options);
    return Promise.resolve(component).then((c) => r.renderAsync(c, thisCopy));
  }
};

// node_modules/jsxte/dist/esm/error-boundary/error-boundary.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp4 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField4 = /* @__PURE__ */ __name((obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
}, "__publicField");
var ErrorBoundary = class {
  static {
    __name(this, "ErrorBoundary");
  }
  /**
   * @internal
   */
  static _isErrorBoundary(o) {
    const canBeClass = typeof o === "function";
    const isNotNull = o !== null;
    if (!canBeClass || !isNotNull)
      return false;
    const baseName = o._baseName;
    return baseName === this._baseName;
  }
  constructor(_) {
  }
};
__publicField4(ErrorBoundary, "_baseName", "ErrorBoundary");

// node_modules/jsxte/dist/esm/utilities/get-component-name.mjs
var getComponentName = /* @__PURE__ */ __name((element) => {
  if (typeof element.tag === "string") {
    return element.tag;
  }
  if ("displayName" in element.tag && typeof element.tag.displayName === "string") {
    return element.tag.displayName;
  }
  if ("name" in element.tag && typeof element.tag.name === "string") {
    return element.tag.name;
  }
  return "AnonymousComponent";
}, "getComponentName");

// node_modules/jsxte/dist/esm/utilities/get-err-message.mjs
var getErrorMessage = /* @__PURE__ */ __name((err) => {
  if (err instanceof Error) {
    return err.message;
  }
  if (typeof err === "string") {
    return err;
  }
  return String(err);
}, "getErrorMessage");

// node_modules/jsxte/dist/esm/renderer/renderer.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp5 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
var __publicField5 = /* @__PURE__ */ __name((obj, key, value) => {
  __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
}, "__publicField");
var NIL = Symbol("NIL");
function isTagElement(element) {
  return typeof element === "object" && element !== null && "type" in element && element.type === "tag";
}
__name(isTagElement, "isTagElement");
function isErrorBoundaryElement(element) {
  return typeof element.tag === "function" && ErrorBoundary._isErrorBoundary(element.tag);
}
__name(isErrorBoundaryElement, "isErrorBoundaryElement");
function isPromiseLike(obj) {
  return obj instanceof Promise || typeof obj === "object" && obj !== null && typeof obj.then === "function" && typeof obj.catch === "function";
}
__name(isPromiseLike, "isPromiseLike");
function asyncError() {
  throw new JsxteRenderError(
    "Encountered an async Component: Asynchronous Component's cannot be parsed by this renderer."
  );
}
__name(asyncError, "asyncError");
var ElementMatcher = class {
  static {
    __name(this, "ElementMatcher");
  }
  constructor(options) {
    this.options = options;
    __publicField5(this, "stringTagHandler");
    __publicField5(this, "functionTagHandler");
    __publicField5(this, "classTagHandler");
    __publicField5(this, "fragmentHandler");
    __publicField5(this, "textHandler");
    __publicField5(this, "primitiveHandler");
    __publicField5(this, "handleError");
  }
  matchSyncElem(element, context) {
    switch (typeof element) {
      case "string":
      case "bigint":
      case "number":
        return this.primitiveHandler(element, context, element);
      case "boolean":
      case "function":
      case "symbol":
      case "undefined":
        return NIL;
    }
    if (element === null) {
      return NIL;
    }
    if (element.type === "textNode") {
      return this.textHandler(element, context, element);
    }
    if (element.type === "tag") {
      if (typeof element.tag === "string") {
        if (element.tag === "") {
          return this.fragmentHandler(element.props.children, context, element);
        }
        return this.stringTagHandler(
          {
            tag: element.tag,
            props: element.props
          },
          context,
          element
        );
      }
      if (typeof element.tag === "function") {
        if (ErrorBoundary._isErrorBoundary(element.tag)) {
          return this.classTagHandler(
            {
              classComponent: element.tag,
              props: element.props
            },
            context,
            element
          );
        } else {
          return this.functionTagHandler(
            {
              funcComponent: element.tag,
              props: element.props
            },
            context,
            element
          );
        }
      }
    }
    return NIL;
  }
  createHandler(func) {
    return (...args) => {
      try {
        const result = func.apply(null, args);
        if (isPromiseLike(result)) {
          return result.catch((err) => {
            return this.handleError(err, args[2], args[1]);
          });
        }
        return result;
      } catch (err) {
        return this.handleError(err, args[2], args[1]);
      }
    };
  }
  functionTag(on) {
    this.functionTagHandler = this.createHandler(on);
    return this;
  }
  classTag(on) {
    this.classTagHandler = this.createHandler(on);
    return this;
  }
  stringTag(on) {
    this.stringTagHandler = this.createHandler(on);
    return this;
  }
  fragment(on) {
    this.fragmentHandler = this.createHandler(on);
    return this;
  }
  text(on) {
    this.textHandler = this.createHandler(on);
    return this;
  }
  primitive(on) {
    this.primitiveHandler = this.createHandler(on);
    return this;
  }
  onError(on) {
    this.handleError = on;
    return this;
  }
  match(element, context) {
    if (isPromiseLike(element)) {
      if (this.options.allowAsync === false) {
        asyncError();
      }
      return element.then((element2) => {
        return this.matchSyncElem(element2, {
          componentApi: ComponentApi.clone(context.componentApi)
        });
      });
    }
    return this.matchSyncElem(element, {
      componentApi: ComponentApi.clone(context.componentApi)
    });
  }
  matchMap(elements, mapFn) {
    const results = [];
    const awaits = [];
    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      const r = mapFn(
        element,
        (element2, context) => this.match(element2, context)
      );
      if (isPromiseLike(r)) {
        if (this.options.allowAsync === false) {
          asyncError();
        }
        awaits.push(
          r.then((result) => {
            if (result !== NIL) {
              results[i] = result;
            }
          })
        );
      } else if (r !== NIL) {
        results[i] = r;
      }
    }
    if (awaits.length === 0) {
      return results;
    }
    return Promise.all(awaits).then(() => {
      return results;
    });
  }
};
var JsxteRenderer = class {
  static {
    __name(this, "JsxteRenderer");
  }
  constructor(generator, options = { allowAsync: false }, rootComponentApi = ComponentApi.create(options)) {
    this.generator = generator;
    this.options = options;
    this.rootComponentApi = rootComponentApi;
    __publicField5(this, "matcher");
    this.matcher = new ElementMatcher(options);
    const renderer = this;
    this.matcher.functionTag((tagElement, context) => {
      const elem = tagElement.funcComponent(
        tagElement.props,
        context.componentApi
      );
      return renderer.renderChild(elem, context);
    }).classTag((tagElement, context) => {
      const compoentInstance = new tagElement.classComponent(
        tagElement.props
      );
      const elem = compoentInstance.render(
        tagElement.props,
        context.componentApi
      );
      return renderer.renderChild(elem, context);
    }).stringTag((tagElement, context) => {
      const { attributes, children } = this.resolveProps(tagElement.props);
      const renderedChildren = this.matcher.matchMap(
        children,
        (child, next) => next(child, {
          componentApi: ComponentApi.clone(context.componentApi)
        })
      );
      return this.generator.createElement(
        tagElement.tag,
        attributes,
        // assume generator accepts promises of T[] (allowAsync is true)
        renderedChildren
      );
    }).fragment((fragmentElement, context) => {
      const childrenArray = Array.isArray(fragmentElement) ? fragmentElement.flat(1) : [fragmentElement];
      const renderedChildren = this.matcher.matchMap(
        childrenArray,
        (child, next) => next(child, {
          componentApi: ComponentApi.clone(context.componentApi)
        })
      );
      return this.generator.createFragment(renderedChildren);
    }).text((textNode) => {
      return this.generator.createTextNode(textNode.text);
    }).primitive((primitive) => {
      return this.generator.createTextNode(primitive);
    }).onError((err, element, context) => {
      if (!isTagElement(element)) {
        throw err;
      }
      if (isErrorBoundaryElement(element)) {
        return this.renderChild(
          {
            type: "tag",
            tag: /* @__PURE__ */ __name(function ErrorHandler() {
              const component = new element.tag(element.props);
              return component.onError(
                err,
                element.props,
                context.componentApi
              );
            }, "ErrorHandler"),
            props: {}
          },
          context
        );
      }
      if (!JsxteRenderError.is(err)) {
        throw new JsxteRenderError(
          "Rendering has failed due to an error: " + getErrorMessage(err),
          getComponentName(element)
        );
      }
      err.pushParent(getComponentName(element));
      throw err;
    });
  }
  mapAttributeName(attributeName) {
    if (this.options.attributeMap && attributeName in this.options.attributeMap) {
      return this.options.attributeMap[attributeName];
    }
    return attributeName;
  }
  resolveProps({
    children,
    ...props
  }) {
    const rprops = {
      attributes: [],
      children: []
    };
    if (children) {
      if (Array.isArray(children)) {
        rprops.children = children.flat(1);
      } else {
        rprops.children = [children];
      }
    }
    const entries = Object.entries(props);
    for (let i = 0; i < entries.length; i++) {
      const [name, value] = entries[i];
      rprops.attributes.push([this.mapAttributeName(name), value]);
    }
    return rprops;
  }
  renderChild(element, context) {
    if (element === null) {
      return NIL;
    }
    return this.matcher.match(element, context);
  }
  render(element) {
    const result = this.renderChild(element, {
      componentApi: this.rootComponentApi
    });
    if (result === NIL) {
      return this.generator.createTextNode("");
    }
    if (isPromiseLike(result)) {
      return result.then((result2) => {
        if (result2 === NIL) {
          return this.generator.createTextNode("");
        }
        return result2;
      });
    }
    return result;
  }
};

// node_modules/jsxte/dist/esm/html-renderer/jsx-elem-to-html-async.mjs
var AsyncHtmlCompactGenerator = class extends BaseHtmlGenerator {
  static {
    __name(this, "AsyncHtmlCompactGenerator");
  }
  createElement(type, attributes, children) {
    return Promise.resolve(children).then((c) => Promise.all(c)).then((children2) => {
      const attributesString = mapAttributesToHtmlTagString(attributes);
      const content = this.flattenChildrenCompact(children2);
      return this.generateTagCompact(type, attributesString, content);
    });
  }
  createTextNode(text) {
    return String(text);
  }
  createFragment(children) {
    return Promise.resolve(children).then((c) => Promise.all(c)).then((children2) => {
      return this.flattenChildrenCompact(children2);
    });
  }
};
var AsyncHtmlPrettyGenerator = class extends BaseHtmlGenerator {
  static {
    __name(this, "AsyncHtmlPrettyGenerator");
  }
  createElement(type, attributes, children) {
    return Promise.resolve(children).then((c) => Promise.all(c)).then((children2) => {
      const attributesString = mapAttributesToHtmlTagString(attributes);
      const content = this.flattenChildren(children2);
      return this.generateTag(type, attributesString, content);
    });
  }
  createTextNode(text) {
    return [{ type: "text", content: String(text) }];
  }
  createFragment(children) {
    return Promise.resolve(children).then((c) => Promise.all(c)).then((children2) => {
      return this.flattenChildren(children2);
    });
  }
};
var jsxElemToHtmlAsync = /* @__PURE__ */ __name((element, componentApi, options = {}) => {
  const { pretty = false } = options;
  if (pretty) {
    const renderer = new JsxteRenderer(
      new AsyncHtmlPrettyGenerator(options),
      { ...options, allowAsync: true },
      componentApi
    );
    const lines = renderer.render(element);
    return Promise.resolve(lines).then(
      (lines2) => AsyncHtmlPrettyGenerator.concatHtmlLines(lines2, options)
    );
  } else {
    const renderer = new JsxteRenderer(
      new AsyncHtmlCompactGenerator(options),
      { ...options, allowAsync: true },
      componentApi
    );
    return Promise.resolve(renderer.render(element));
  }
}, "jsxElemToHtmlAsync");

// node_modules/jsxte/dist/esm/json-renderer/render-to-json.mjs
var renderToJson = /* @__PURE__ */ __name((component, options) => {
  try {
    return jsxElemToJsonSync(component, void 0, options);
  } catch (err) {
    if (JsxteRenderError.is(err)) {
      err.regenerateMessage();
    }
    throw err;
  }
}, "renderToJson");

// node_modules/jsxte-wc/dist/index.js
var __defProp7 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp7(target, "name", { value, configurable: true }), "__name");
var ArrayMap = class {
  static {
    __name(this, "ArrayMap");
  }
  static {
    __name2(this, "ArrayMap");
  }
  entries = [];
  get size() {
    return this.entries.length;
  }
  at(index) {
    return this.entries[index]?.slice();
  }
  set(key, value) {
    const index = this.entries.findIndex(([k]) => k === key);
    if (index === -1) {
      this.entries.push([key, value]);
    } else {
      this.entries[index] = [key, value];
    }
  }
  get(key) {
    const entry = this.entries.find(([k]) => k === key);
    return entry?.[1];
  }
  has(key) {
    return this.entries.some(([k]) => k === key);
  }
  clear() {
    this.entries = [];
  }
  delete(key) {
    const index = this.entries.findIndex(([k]) => k === key);
    if (index === -1)
      return false;
    this.entries.splice(index, 1);
    return true;
  }
  keys() {
    return this.entries.map(([k]) => k);
  }
  values() {
    return this.entries.map(([, v]) => v);
  }
  forEach(cb) {
    for (let i = 0; i < this.entries.length; i++) {
      const [key, value] = this.entries[i];
      cb(value, key);
    }
  }
};
var ElementLifecycleEvent = /* @__PURE__ */ ((ElementLifecycleEvent2) => {
  ElementLifecycleEvent2["WillUpdate"] = "element-will-update";
  ElementLifecycleEvent2["DidUpdate"] = "element-did-update";
  ElementLifecycleEvent2["WillMount"] = "element-will-mount";
  ElementLifecycleEvent2["DidMount"] = "element-did-mount";
  ElementLifecycleEvent2["DidUnmount"] = "element-did-unmount";
  ElementLifecycleEvent2["SlotDidChange"] = "element-slot-did-change";
  ElementLifecycleEvent2["StateDidChange"] = "element-state-did-change";
  ElementLifecycleEvent2["AttributeDidChange"] = "element-attribute-did-change";
  return ElementLifecycleEvent2;
})(ElementLifecycleEvent || {});
var ElementWillUpdateEvent = class extends CustomEvent {
  static {
    __name(this, "ElementWillUpdateEvent");
  }
  static {
    __name2(this, "ElementWillUpdateEvent");
  }
  constructor() {
    super(
      "element-will-update"
      /* WillUpdate */
    );
  }
};
var ElementDidUpdateEvent = class extends CustomEvent {
  static {
    __name(this, "ElementDidUpdateEvent");
  }
  static {
    __name2(this, "ElementDidUpdateEvent");
  }
  constructor() {
    super(
      "element-did-update"
      /* DidUpdate */
    );
  }
};
var ElementWillMountEvent = class extends CustomEvent {
  static {
    __name(this, "ElementWillMountEvent");
  }
  static {
    __name2(this, "ElementWillMountEvent");
  }
  constructor() {
    super(
      "element-will-mount"
      /* WillMount */
    );
  }
};
var ElementDidMountEvent = class extends CustomEvent {
  static {
    __name(this, "ElementDidMountEvent");
  }
  static {
    __name2(this, "ElementDidMountEvent");
  }
  constructor() {
    super(
      "element-did-mount"
      /* DidMount */
    );
  }
};
var ElementDidUnmountEvent = class extends CustomEvent {
  static {
    __name(this, "ElementDidUnmountEvent");
  }
  static {
    __name2(this, "ElementDidUnmountEvent");
  }
  constructor() {
    super(
      "element-did-unmount"
      /* DidUnmount */
    );
  }
};
var ElementSlotDidChangeEvent = class extends CustomEvent {
  static {
    __name(this, "ElementSlotDidChangeEvent");
  }
  static {
    __name2(this, "ElementSlotDidChangeEvent");
  }
  constructor(slotName, changes) {
    super("element-slot-did-change", {
      detail: {
        slotName,
        changes
      }
    });
  }
};
var ElementStateDidChangeEvent = class extends CustomEvent {
  static {
    __name(this, "ElementStateDidChangeEvent");
  }
  static {
    __name2(this, "ElementStateDidChangeEvent");
  }
  constructor(stateName, prevValue, newValue) {
    super("element-state-did-change", {
      detail: {
        stateName,
        prevValue,
        newValue
      }
    });
  }
};
var ElementAttributeDidChangeEvent = class extends CustomEvent {
  static {
    __name(this, "ElementAttributeDidChangeEvent");
  }
  static {
    __name2(this, "ElementAttributeDidChangeEvent");
  }
  constructor(attributeName, prevValue, newValue) {
    super("element-attribute-did-change", {
      detail: {
        attributeName,
        prevValue,
        newValue
      }
    });
  }
};
var Attribute = class {
  static {
    __name(this, "Attribute");
  }
  constructor(name, parser) {
    this.name = name;
    this.parser = parser;
  }
  static {
    __name2(this, "Attribute");
  }
  current = null;
  onChange = null;
  onSet = null;
  get() {
    return this.current;
  }
  setInternal(v) {
    this.current = v;
  }
  set(v) {
    const newValue = v;
    if (!Object.is(this.current, newValue)) {
      const prevValue = this.current;
      this.current = newValue;
      this.onChange?.(newValue, prevValue);
      this.onSet?.();
    }
  }
  isEqualTo(v) {
    return Object.is(this.current, v);
  }
  isEqualToRaw(v) {
    return Object.is(this.current, this.parser(v));
  }
  syncDown(element) {
    const v = element.getAttribute(this.name);
    const newValue = this.parser(v);
    if (!Object.is(this.current, newValue)) {
      const prevValue = this.current;
      this.current = newValue;
      this.onChange?.(newValue, prevValue);
    }
  }
  syncUp(element) {
    if (this.current === null) {
      element.removeAttribute(this.name);
    } else {
      element.setAttribute(this.name, String(this.current));
    }
  }
};
var AttributeController = class {
  static {
    __name(this, "AttributeController");
  }
  constructor(element) {
    this.element = element;
  }
  static {
    __name2(this, "AttributeController");
  }
  attributes = new ArrayMap();
  registerAttribute(attribute) {
    this.attributes.set(attribute.name, attribute);
    this.element.observeAttribute(attribute.name);
    attribute.onChange = (newValue, prevValue) => {
      this.element.requestUpdate();
      this.element.lifecycle.dispatchEvent(
        new ElementAttributeDidChangeEvent(
          attribute.name,
          prevValue,
          newValue
        )
      );
    };
    attribute.onSet = () => {
      attribute.syncUp(this.element);
    };
  }
  getAttribute(name) {
    return this.attributes.get(name);
  }
  detectedPossibleChange(mutation) {
    const attribute = this.attributes.get(mutation.attributeName);
    if (attribute) {
      attribute.syncDown(this.element);
    }
  }
  syncUpAll() {
    this.attributes.forEach((attribute) => {
      attribute.syncUp(this.element);
    });
  }
};
function nullableNumberParser(value) {
  return value === null ? null : Number(value);
}
__name(nullableNumberParser, "nullableNumberParser");
__name2(nullableNumberParser, "nullableNumberParser");
function nonNullableNumberParser(value, defaultValue = 0) {
  return value === null ? defaultValue : Number(value);
}
__name(nonNullableNumberParser, "nonNullableNumberParser");
__name2(nonNullableNumberParser, "nonNullableNumberParser");
function nullableStringParser(value) {
  return value;
}
__name(nullableStringParser, "nullableStringParser");
__name2(nullableStringParser, "nullableStringParser");
function nonNullableStringParser(value, defaultValue = "") {
  return value === null ? defaultValue : value;
}
__name(nonNullableStringParser, "nonNullableStringParser");
__name2(nonNullableStringParser, "nonNullableStringParser");
function nullableBooleanParser(attributeName, value) {
  switch (value) {
    case "":
    case "true":
      return true;
    case "false":
      return false;
  }
  if (typeof value === "string") {
    return value === attributeName;
  }
  return null;
}
__name(nullableBooleanParser, "nullableBooleanParser");
__name2(nullableBooleanParser, "nullableBooleanParser");
function nonNullableBooleanParser(attributeName, value, defaultValue = false) {
  switch (value) {
    case "":
    case "true":
      return true;
    case "false":
      return false;
  }
  return value === attributeName ? true : defaultValue;
}
__name(nonNullableBooleanParser, "nonNullableBooleanParser");
__name2(nonNullableBooleanParser, "nonNullableBooleanParser");
function attribValueParserFactory(attributeName, opts) {
  const { nullable = false } = opts;
  switch (opts.type) {
    case "number":
      if (nullable) {
        return nullableNumberParser;
      }
      return (v) => nonNullableNumberParser(v, opts.default);
    case "boolean":
      if (nullable) {
        return (v) => nullableBooleanParser(attributeName, v);
      }
      return (v) => nonNullableBooleanParser(
        attributeName,
        v,
        opts.default
      );
  }
  if (nullable) {
    return nullableStringParser;
  }
  return (v) => nonNullableStringParser(v, opts.default);
}
__name(attribValueParserFactory, "attribValueParserFactory");
__name2(attribValueParserFactory, "attribValueParserFactory");
function Attribute2(opts = {}) {
  return (accessor, context) => {
    const attributeName = (opts.name ?? context.name).toLowerCase();
    const valueParser = attribValueParserFactory(
      attributeName,
      opts
    );
    return {
      get() {
        return this["_attributeController"].getAttribute(attributeName)?.get();
      },
      set(value) {
        this["_attributeController"].getAttribute(attributeName)?.set(value);
      },
      init(value) {
        const attr = new Attribute(attributeName, valueParser);
        this["_attributeController"].registerAttribute(attr);
        const htmlValue = this.getAttribute(attributeName);
        if (htmlValue !== null) {
          attr.setInternal(valueParser(htmlValue));
        } else {
          attr.setInternal(value == null ? valueParser(null) : value);
        }
        this.lifecycle.on("element-will-mount", () => {
          const htmlValue2 = this.getAttribute(attributeName);
          if (!attr.isEqualToRaw(htmlValue2)) {
            attr.setInternal(valueParser(htmlValue2));
          }
        });
        return attr.get();
      }
    };
  };
}
__name(Attribute2, "Attribute2");
__name2(Attribute2, "Attribute");
function CustomElement(tagName) {
  return (target, _) => {
    customElements.define(tagName, target);
  };
}
__name(CustomElement, "CustomElement");
__name2(CustomElement, "CustomElement");
var SlotAttributeChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SlotAttributeChangeEvent");
  }
  static {
    __name2(this, "SlotAttributeChangeEvent");
  }
  constructor(node) {
    super("slotattributechange", {
      bubbles: true,
      cancelable: true,
      detail: { node }
    });
  }
};
var SlotContentChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SlotContentChangeEvent");
  }
  static {
    __name2(this, "SlotContentChangeEvent");
  }
  constructor(node) {
    super("slotcontentchange", {
      bubbles: true,
      cancelable: true,
      detail: { node }
    });
  }
};
var WcSlot = class extends HTMLElement {
  static {
    __name(this, "WcSlot");
  }
  static {
    __name2(this, "WcSlot");
  }
  _isWcSlot = true;
  static isSlot(elem) {
    return elem._isWcSlot === true;
  }
  _observer = new MutationObserver(
    (a) => this._handleObserverEvent(a)
  );
  emitter = new EventTarget();
  constructor() {
    super();
  }
  _handleObserverEvent(mutations) {
    if (this.shouldEmitAttributeChangeEvent(mutations)) {
      this.emitter.dispatchEvent(new SlotAttributeChangeEvent(this));
    }
    if (this.shouldEmitContentChangeEvent(mutations)) {
      this.emitter.dispatchEvent(new SlotContentChangeEvent(this));
    }
  }
  shouldEmitAttributeChangeEvent(mutations) {
    for (let i = 0; i < mutations.length; i++) {
      const mutation = mutations[i];
      if (mutation.type === "attributes" && mutation.attributeName && mutation.oldValue !== this.getAttribute(mutation.attributeName)) {
        return true;
      }
    }
    return false;
  }
  shouldEmitContentChangeEvent(mutations) {
    for (let i = 0; i < mutations.length; i++) {
      const mutation = mutations[i];
      if (mutation.type === "childList" || mutation.type === "characterData") {
        return true;
      }
    }
    return false;
  }
  connectedCallback() {
    this.style.display = "none";
    this._observer.observe(this, {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true,
      attributeOldValue: true
    });
  }
  disconnectedCallback() {
    this._observer.disconnect();
  }
};
var defaultShouldUpdate = /* @__PURE__ */ __name2((current, changes) => {
  return changes.added.length > 0 || changes.removed.length > 0 || changes.contentChanged.length > 0 || changes.attributeChanged.length > 0;
}, "defaultShouldUpdate");
function Slotted(opts = {}) {
  return (accessor, context) => {
    const { filter: optFilter } = opts;
    let filter = /* @__PURE__ */ __name2(() => true, "filter");
    switch (typeof optFilter) {
      case "string":
        filter = /* @__PURE__ */ __name2((elem) => elem.matches(optFilter), "filter");
        break;
      case "function":
        filter = optFilter;
        break;
    }
    const { shouldRequestUpdate = defaultShouldUpdate } = opts;
    const updateSlots = /* @__PURE__ */ __name2((elem, changes) => {
      let current = accessor.get.call(elem).slice();
      const shouldAdd = changes.added.filter(filter);
      const shouldRemove = changes.removed;
      const added = [];
      const removed = [];
      const contentChanged = [];
      const attributeChanged = [];
      for (let i = 0; i < changes.attributeChanged.length; i++) {
        const slot = changes.attributeChanged[i];
        if (filter(slot)) {
          const idx = current.indexOf(slot);
          if (idx === -1) {
            current.push(slot);
            added.push(slot);
          } else {
            attributeChanged.push(slot);
          }
        } else {
          const idx = current.indexOf(shouldRemove[i]);
          if (idx !== -1) {
            current.splice(idx, 1);
            removed.push(slot);
          }
        }
      }
      for (let i = 0; i < changes.contentChanged.length; i++) {
        const slot = changes.contentChanged[i];
        if (filter(slot)) {
          const idx = current.indexOf(slot);
          if (idx === -1) {
            current.push(slot);
            added.push(slot);
          } else {
            contentChanged.push(slot);
          }
        } else {
          const idx = current.indexOf(shouldRemove[i]);
          if (idx !== -1) {
            current.splice(idx, 1);
            removed.push(slot);
          }
        }
      }
      for (let i = 0; i < shouldRemove.length; i++) {
        const idx = current.indexOf(shouldRemove[i]);
        if (idx !== -1) {
          current.splice(idx, 1);
          removed.push(shouldRemove[i]);
        }
      }
      for (let i = 0; i < shouldAdd.length; i++) {
        const slot = shouldAdd[i];
        const idx = current.indexOf(slot);
        if (idx === -1) {
          current.push(slot);
          added.push(slot);
        }
      }
      accessor.set.call(elem, current);
      const finalChanges = {
        added,
        removed,
        contentChanged,
        attributeChanged
      };
      return finalChanges;
    }, "updateSlots");
    context.addInitializer(function() {
      this.observeSlots((changes) => {
        const finalChanges = updateSlots(this, changes);
        if (shouldRequestUpdate(accessor.get.call(this), finalChanges)) {
          this.requestUpdate();
        }
        this.lifecycle.dispatchEvent(
          new ElementSlotDidChangeEvent(
            context.name,
            finalChanges
          )
        );
      });
      this.lifecycle.once("element-did-mount", () => {
        const children = Array.from(this.children);
        const initValue = [];
        for (let i = 0; i < children.length; i++) {
          const elem = children[i];
          if (WcSlot.isSlot(elem) && filter(elem)) {
            initValue.push(elem);
            this.connectToWcSlot(elem);
          }
        }
        accessor.set.call(this, initValue);
        const finalChanges = {
          added: initValue,
          attributeChanged: [],
          contentChanged: [],
          removed: []
        };
        if (shouldRequestUpdate(accessor.get.call(this), finalChanges)) {
          this.requestUpdate();
        }
        this.lifecycle.dispatchEvent(
          new ElementSlotDidChangeEvent(
            context.name,
            finalChanges
          )
        );
      });
    });
    return {
      set() {
      },
      get() {
        return accessor.get.call(this);
      },
      init() {
        return [];
      }
    };
  };
}
__name(Slotted, "Slotted");
__name2(Slotted, "Slotted");
function State() {
  return (accessor, context) => {
    return {
      get() {
        return accessor.get.call(this);
      },
      set(value) {
        const prevValue = accessor.get.call(this);
        if (!Object.is(prevValue, value)) {
          accessor.set.call(this, value);
          this.requestUpdate();
          this.lifecycle.dispatchEvent(
            new ElementStateDidChangeEvent(
              context.name,
              prevValue,
              value
            )
          );
        }
      }
    };
  };
}
__name(State, "State");
__name2(State, "State");
var EventEmitter = class extends EventTarget {
  static {
    __name(this, "EventEmitter");
  }
  static {
    __name2(this, "EventEmitter");
  }
  once(type, listener, capture) {
    super.addEventListener(type, listener, {
      once: true,
      capture
    });
  }
  on(type, listener, capture) {
    super.addEventListener(type, listener, {
      capture
    });
  }
  off(type, listener) {
    super.removeEventListener(type, listener);
  }
  addEventListener(type, listener, capture) {
    super.addEventListener(type, listener, {
      capture
    });
  }
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    return super.dispatchEvent(event);
  }
};
function expandFragments(elements) {
  let expandedElements = [];
  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];
    if (typeof element === "string") {
      expandedElements.push(element);
      continue;
    }
    if (element.element === "") {
      expandedElements = expandedElements.concat(
        expandFragments(element.children)
      );
      continue;
    }
    expandedElements.push(element);
  }
  return expandedElements;
}
__name(expandFragments, "expandFragments");
__name2(expandFragments, "expandFragments");
function attributeSetterFactory(element, attr) {
  if (attr.startsWith("on")) {
    let lastValue = void 0;
    return (value) => {
      if (value === lastValue)
        return;
      const eventName = attr.slice(2).toLowerCase();
      if (lastValue) {
        element.removeEventListener(eventName, lastValue);
      }
      element.addEventListener(eventName, value);
      lastValue = value;
    };
  } else if (attr === "value" && "value" in element) {
    let lastValue = attr[1];
    return (value) => {
      if (value === lastValue)
        return;
      lastValue = value;
      if (value == null || value === false) {
        element.removeAttribute(attr);
        element.value = "";
      } else {
        element.setAttribute(attr, value);
        element.value = value;
      }
    };
  } else {
    let lastValue = attr[1];
    return (value) => {
      if (value === lastValue)
        return;
      lastValue = value;
      if (value == null || value === false) {
        element.removeAttribute(attr);
      } else {
        element.setAttribute(attr, value);
      }
    };
  }
}
__name(attributeSetterFactory, "attributeSetterFactory");
__name2(attributeSetterFactory, "attributeSetterFactory");
var VirtualTextNode = class {
  static {
    __name(this, "VirtualTextNode");
  }
  constructor(text) {
    this.text = text;
    this.element.textContent = text;
  }
  static {
    __name2(this, "VirtualTextNode");
  }
  elementName = "text-node";
  element = document.createTextNode("");
  update(text) {
    if (text === this.text)
      return;
    this.text = text;
    this.element.textContent = text;
  }
  cleanup() {
  }
};
var VirtualElement = class _VirtualElement {
  static {
    __name(this, "_VirtualElement");
  }
  static {
    __name2(this, "VirtualElement");
  }
  static createVirtual(elemJson) {
    switch (typeof elemJson) {
      case "string":
        return new VirtualTextNode(elemJson);
      case "object":
        return new _VirtualElement(elemJson);
    }
  }
  static createFor(name, element) {
    const instance = Object.setPrototypeOf(
      {
        elementName: name,
        element,
        lastUpdatedAttributes: [],
        children: [],
        attributes: new ArrayMap()
      },
      _VirtualElement.prototype
    );
    return instance;
  }
  elementName;
  element;
  ref;
  lastUpdatedAttributes = [];
  children = [];
  attributes = new ArrayMap();
  constructor(elemJson) {
    this.elementName = elemJson.element;
    this.element = document.createElement(this.elementName);
    this.updateAttributes(elemJson.attributes);
    this.updateChildren(elemJson.children);
  }
  setAttribute(attr) {
    let setter = this.attributes.get(attr[0]);
    if (!setter) {
      setter = attributeSetterFactory(this.element, attr[0]);
      this.attributes.set(attr[0], setter);
    }
    setter(attr[1]);
  }
  updateAttributes(attributes) {
    const updatedAttributes = [];
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      if (attribute[0] === "ref") {
        const ref = attribute[1];
        ref.current = this.element;
        this.ref = ref;
        continue;
      }
      this.setAttribute(attribute);
      updatedAttributes.push(attribute[0]);
    }
    for (let i = 0; i < this.lastUpdatedAttributes.length; i++) {
      const attributeName = this.lastUpdatedAttributes[i];
      if (!updatedAttributes.includes(attributeName)) {
        const attrSetter = this.attributes.get(attributeName);
        attrSetter(void 0);
      }
    }
    this.lastUpdatedAttributes = updatedAttributes;
  }
  updateChildren(children) {
    children = expandFragments(children);
    if (this.children.length > children.length) {
      for (let i = children.length; i < this.children.length; i++) {
        const child = this.children[i];
        this.element.removeChild(child.element);
        child.cleanup();
      }
      this.children.splice(children.length);
    }
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const prevChild = this.children[i];
      if (!prevChild) {
        const newChild = _VirtualElement.createVirtual(child);
        this.children[i] = newChild;
        this.element.appendChild(newChild.element);
        continue;
      }
      if (typeof child === "string") {
        if (prevChild.elementName === "text-node") {
          prevChild.update(child);
        } else {
          const newChild = new VirtualTextNode(child);
          this.children[i] = newChild;
          this.element.replaceChild(
            newChild.element,
            prevChild.element
          );
        }
      } else {
        if (prevChild.elementName === child.element) {
          prevChild.update(child);
        } else {
          const newChild = new _VirtualElement(child);
          this.children[i] = newChild;
          this.element.replaceChild(
            newChild.element,
            prevChild.element
          );
        }
      }
    }
  }
  getChildElements() {
    const result = [];
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      result.push(child.element);
    }
    return result;
  }
  update(elemJson) {
    this.updateAttributes(elemJson.attributes);
    this.updateChildren(elemJson.children);
  }
  cleanup() {
    if (this.ref) {
      this.ref.current = null;
    }
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].cleanup();
    }
  }
};
var RequestBatch = class {
  static {
    __name(this, "RequestBatch");
  }
  constructor(callback) {
    this.callback = callback;
  }
  static {
    __name2(this, "RequestBatch");
  }
  status = "idle";
  request() {
    if (this.status === "waiting") {
      return;
    }
    this.status = "waiting";
    queueMicrotask(() => {
      let runAfter;
      try {
        runAfter = this.callback();
      } finally {
        this.status = "idle";
        runAfter?.();
      }
    });
  }
};
var noop = /* @__PURE__ */ __name2(() => {
}, "noop");
var createRoot = /* @__PURE__ */ __name2((element) => {
  const root = document.createElement("div");
  root.style.display = "contents";
  const additionalClassNames = element.getRootClassNames?.() ?? [];
  root.classList.add("wc-root", ...additionalClassNames);
  return root;
}, "createRoot");
var Element = class extends HTMLElement {
  static {
    __name(this, "Element");
  }
  static {
    __name2(this, "Element");
  }
  _vroot;
  _root = createRoot(this);
  _requestBatch = new RequestBatch(() => this._updateDom());
  _attributeObserver = new MutationObserver(
    (a) => this._handleObserverEvent(a)
  );
  _attributeController = new AttributeController(this);
  _observedAttributes = [];
  _isObservingSlots = false;
  _slotChangeListeners = [];
  _isConnected = false;
  _dependencySelector = new Proxy(
    {},
    {
      get: /* @__PURE__ */ __name((_, prop) => {
        return {
          getValue: /* @__PURE__ */ __name(() => this[prop], "getValue"),
          name: prop
        };
      }, "get")
    }
  );
  lifecycle = new EventEmitter();
  constructor() {
    super();
  }
  _performFirstMount() {
    this.lifecycle.dispatchEvent(new ElementWillMountEvent());
    this._attributeController.syncUpAll();
    const jsxElem = this.render();
    const json = renderToJson(jsxElem);
    this._vroot = VirtualElement.createFor("<root>", this._root);
    this._vroot.updateChildren([json]);
    return () => this.lifecycle.dispatchEvent(new ElementDidMountEvent());
  }
  _preformNextUpdate() {
    this.lifecycle.dispatchEvent(new ElementWillUpdateEvent());
    const jsxElem = this.render();
    const json = renderToJson(jsxElem);
    this._vroot.updateChildren([json]);
    return () => this.lifecycle.dispatchEvent(new ElementDidUpdateEvent());
  }
  _updateDom() {
    if (this._vroot) {
      return this._preformNextUpdate();
    } else {
      return this._performFirstMount();
    }
  }
  _handleObserverEvent(mutationRecord) {
    for (let i = 0; i < mutationRecord.length; i++) {
      const record = mutationRecord[i];
      if (record.attributeName) {
        this._attributeController.detectedPossibleChange(record);
      } else if (record.type === "childList") {
        this._handleContentMutation(record);
      }
    }
  }
  _handleContentMutation(record) {
    const added = [];
    const removed = [];
    for (let j = 0; j < record.addedNodes.length; j++) {
      const node = record.addedNodes[j];
      if (WcSlot.isSlot(node)) {
        added.push(node);
        this.connectToWcSlot(node);
      }
    }
    for (let j = 0; j < record.removedNodes.length; j++) {
      const node = record.removedNodes[j];
      if (WcSlot.isSlot(node)) {
        removed.push(node);
        this.disconnectFromWcSlot(node);
      }
    }
    for (const listener of this._slotChangeListeners) {
      listener({
        added: added.slice(),
        removed: removed.slice(),
        attributeChanged: [],
        contentChanged: []
      });
    }
  }
  connectToWcSlot(node) {
    node.emitter.addEventListener(
      "slotcontentchange",
      this.handleSlotContentChange
    );
    node.emitter.addEventListener(
      "slotattributechange",
      this.handleSlotAttributeChange
    );
  }
  disconnectFromWcSlot(node) {
    node.emitter.removeEventListener(
      "slotcontentchange",
      this.handleSlotContentChange
    );
    node.emitter.removeEventListener(
      "slotattributechange",
      this.handleSlotAttributeChange
    );
  }
  handleSlotContentChange = /* @__PURE__ */ __name((event) => {
    for (const listener of this._slotChangeListeners) {
      listener({
        contentChanged: [event.detail.node],
        attributeChanged: [],
        added: [],
        removed: []
      });
    }
  }, "handleSlotContentChange");
  handleSlotAttributeChange = /* @__PURE__ */ __name((event) => {
    for (const listener of this._slotChangeListeners) {
      listener({
        contentChanged: [],
        attributeChanged: [event.detail.node],
        added: [],
        removed: []
      });
    }
  }, "handleSlotAttributeChange");
  observeAttribute(attributeName) {
    this._observedAttributes.push(attributeName);
  }
  observeSlots(listener) {
    this._isObservingSlots = true;
    this._slotChangeListeners.push(listener);
  }
  requestUpdate() {
    if (this._isConnected) {
      this._requestBatch.request();
    }
  }
  connectedCallback() {
    this.appendChild(this._root);
    this._isConnected = true;
    this._attributeObserver.observe(this, {
      attributeFilter: this._observedAttributes,
      attributeOldValue: true,
      attributes: true,
      childList: this._isObservingSlots,
      subtree: false
    });
    this.requestUpdate();
  }
  disconnectedCallback() {
    this._isConnected = false;
    this._attributeObserver.disconnect();
    const children = Array.from(this.children);
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (WcSlot.isSlot(child)) {
        this.disconnectFromWcSlot(child);
      }
    }
    this.lifecycle.dispatchEvent(new ElementDidUnmountEvent());
  }
  /**
   * Registers a callback that will be ran on every change of the
   * specified dependencies (attribute or state) and after first
   * mount.
   *
   * This effect always happens after the DOM has been updated.
   *
   * @returns A `stop` function that cancels the effect.
   */
  effect(cb, getDependencies) {
    const deps = getDependencies(this._dependencySelector);
    let cleanup = noop;
    const runCleanup = /* @__PURE__ */ __name2(() => {
      cleanup();
      cleanup = noop;
    }, "runCleanup");
    const callback = /* @__PURE__ */ __name2((effect) => {
      runCleanup();
      cleanup = cb(effect) ?? noop;
    }, "callback");
    if (!deps) {
      const didMountHandler2 = /* @__PURE__ */ __name2(() => {
        callback({
          isFirstMount: true
        });
      }, "didMountHandler");
      const didUpdateHandler2 = /* @__PURE__ */ __name2(() => {
        callback({
          isFirstMount: false
        });
      }, "didUpdateHandler");
      this.lifecycle.once(
        "element-did-unmount",
        runCleanup
      );
      this.lifecycle.once(
        "element-did-mount",
        didMountHandler2
      );
      this.lifecycle.on(
        "element-did-update",
        didUpdateHandler2
      );
      return () => {
        this.lifecycle.off(
          "element-did-unmount",
          runCleanup
        );
        this.lifecycle.off(
          "element-did-mount",
          didMountHandler2
        );
        this.lifecycle.off(
          "element-did-update",
          didUpdateHandler2
        );
        runCleanup();
      };
    }
    if (deps.length === 0) {
      const handler = /* @__PURE__ */ __name2(() => {
        callback({
          isFirstMount: true
        });
      }, "handler");
      this.lifecycle.once(
        "element-did-unmount",
        runCleanup
      );
      this.lifecycle.once("element-did-mount", handler);
      return () => {
        this.lifecycle.off(
          "element-did-unmount",
          runCleanup
        );
        this.lifecycle.off("element-did-mount", handler);
        runCleanup();
      };
    }
    const depNamesForAttr = deps.map((d) => d.name.toLowerCase());
    const depNamesForSlotOrState = deps.map((d) => d.name);
    let runCallbackOnNextUpdate = false;
    const attribChangeHandler = /* @__PURE__ */ __name2((ev) => {
      if (depNamesForAttr.includes(ev.detail.attributeName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "attribChangeHandler");
    const stateChangeHandler = /* @__PURE__ */ __name2((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.stateName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "stateChangeHandler");
    const slotChangeHandler = /* @__PURE__ */ __name2((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.slotName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "slotChangeHandler");
    const didUpdateHandler = /* @__PURE__ */ __name2(() => {
      if (runCallbackOnNextUpdate) {
        runCallbackOnNextUpdate = false;
        callback({
          isFirstMount: false
        });
      }
    }, "didUpdateHandler");
    const didMountHandler = /* @__PURE__ */ __name2(() => {
      runCallbackOnNextUpdate = false;
      callback({
        isFirstMount: true
      });
    }, "didMountHandler");
    this.lifecycle.once(
      "element-did-mount",
      didMountHandler
    );
    this.lifecycle.once("element-did-unmount", runCleanup);
    this.lifecycle.on(
      "element-attribute-did-change",
      attribChangeHandler
    );
    this.lifecycle.on(
      "element-state-did-change",
      stateChangeHandler
    );
    this.lifecycle.on(
      "element-slot-did-change",
      slotChangeHandler
    );
    this.lifecycle.on(
      "element-did-update",
      didUpdateHandler
    );
    const cancel = /* @__PURE__ */ __name2(() => {
      this.lifecycle.off(
        "element-did-mount",
        didMountHandler
      );
      this.lifecycle.off(
        "element-did-unmount",
        runCleanup
      );
      this.lifecycle.off(
        "element-attribute-did-change",
        attribChangeHandler
      );
      this.lifecycle.off(
        "element-state-did-change",
        stateChangeHandler
      );
      this.lifecycle.off(
        "element-slot-did-change",
        slotChangeHandler
      );
      this.lifecycle.off(
        "element-did-update",
        didUpdateHandler
      );
      runCleanup();
    }, "cancel");
    return cancel;
  }
  /**
   * Registers a callback that will be ran on every change of the
   * specified dependencies (attribute or state) and before first
   * mount.
   *
   * This effect always happens right before the render, meaning that
   * state and attribute changes within it will affect the subsequent
   * render result and won't trigger another re-render.
   *
   * @returns A `stop` function that cancels the effect.
   */
  immediateEffect(cb, getDependencies) {
    const deps = getDependencies(this._dependencySelector);
    let cleanup = noop;
    const runCleanup = /* @__PURE__ */ __name2(() => {
      cleanup();
      cleanup = noop;
    }, "runCleanup");
    const callback = /* @__PURE__ */ __name2((effect) => {
      runCleanup();
      cleanup = cb(effect) ?? noop;
    }, "callback");
    if (!deps) {
      const willMountHandler2 = /* @__PURE__ */ __name2(() => {
        callback({
          isFirstMount: true
        });
      }, "willMountHandler");
      const willUpdateHandler2 = /* @__PURE__ */ __name2(() => {
        callback({
          isFirstMount: false
        });
      }, "willUpdateHandler");
      this.lifecycle.once(
        "element-did-unmount",
        runCleanup
      );
      this.lifecycle.once(
        "element-will-mount",
        willMountHandler2
      );
      this.lifecycle.on(
        "element-will-update",
        willUpdateHandler2
      );
      return () => {
        this.lifecycle.off(
          "element-did-unmount",
          runCleanup
        );
        this.lifecycle.off(
          "element-will-mount",
          willMountHandler2
        );
        this.lifecycle.off(
          "element-will-update",
          willUpdateHandler2
        );
        runCleanup();
      };
    }
    if (deps.length === 0) {
      const handler = /* @__PURE__ */ __name2(() => {
        callback({
          isFirstMount: true
        });
      }, "handler");
      this.lifecycle.once("element-will-mount", handler);
      return () => {
        this.lifecycle.off("element-will-mount", handler);
        runCleanup();
      };
    }
    const depNamesForAttr = deps.map((d) => d.name.toLowerCase());
    const depNamesForSlotOrState = deps.map((d) => d.name);
    let runCallbackOnNextUpdate = false;
    const attribChangeHandler = /* @__PURE__ */ __name2((ev) => {
      if (depNamesForAttr.includes(ev.detail.attributeName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "attribChangeHandler");
    const stateChangeHandler = /* @__PURE__ */ __name2((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.stateName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "stateChangeHandler");
    const slotChangeHandler = /* @__PURE__ */ __name2((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.slotName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "slotChangeHandler");
    const willUpdateHandler = /* @__PURE__ */ __name2(() => {
      if (runCallbackOnNextUpdate) {
        runCallbackOnNextUpdate = false;
        callback({
          isFirstMount: false
        });
      }
    }, "willUpdateHandler");
    const willMountHandler = /* @__PURE__ */ __name2(() => {
      runCallbackOnNextUpdate = false;
      callback({
        isFirstMount: true
      });
    }, "willMountHandler");
    this.lifecycle.once(
      "element-will-mount",
      willMountHandler
    );
    this.lifecycle.once("element-did-unmount", runCleanup);
    this.lifecycle.on(
      "element-attribute-did-change",
      attribChangeHandler
    );
    this.lifecycle.on(
      "element-state-did-change",
      stateChangeHandler
    );
    this.lifecycle.on(
      "element-slot-did-change",
      slotChangeHandler
    );
    this.lifecycle.on(
      "element-will-update",
      willUpdateHandler
    );
    const cancel = /* @__PURE__ */ __name2(() => {
      this.lifecycle.off(
        "element-will-mount",
        willMountHandler
      );
      this.lifecycle.off(
        "element-did-unmount",
        runCleanup
      );
      this.lifecycle.off(
        "element-attribute-did-change",
        attribChangeHandler
      );
      this.lifecycle.off(
        "element-state-did-change",
        stateChangeHandler
      );
      this.lifecycle.off(
        "element-slot-did-change",
        slotChangeHandler
      );
      this.lifecycle.off(
        "element-will-update",
        willUpdateHandler
      );
      runCleanup();
    }, "cancel");
    return cancel;
  }
};

// src/base-elements.ts
var BaseElement = class extends Element {
  constructor() {
    super(...arguments);
    this.getRootClassNames = void 0;
  }
  static {
    __name(this, "BaseElement");
  }
};

// src/index.css
var stylesheet = "._adw_hidden{display:none}._adw_col{flex-direction:column}";
var exports = {
  css: stylesheet,
  element: null
};
(function() {
  if (typeof window !== "undefined") {
    const head = document.head;
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(stylesheet));
    head.appendChild(style);
    exports.element = style;
  }
})();

// src/utils/cls.ts
function cls(classNames) {
  if (classNames === void 0) {
    return "";
  }
  if (typeof classNames === "string") {
    return classNames;
  }
  let result = "";
  if (Array.isArray(classNames)) {
    for (let i = 0; i < classNames.length; i++) {
      result += cls(classNames[i]) + " ";
    }
  } else {
    const entries = Object.entries(classNames);
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      if (value) {
        result += key + " ";
      }
    }
  }
  return result.substring(0, result.length - 1);
}
__name(cls, "cls");

// src/utils/events.ts
var CustomMouseEvent = class extends CustomEvent {
  static {
    __name(this, "CustomMouseEvent");
  }
  constructor(name, detail, base) {
    super(name, {
      detail,
      bubbles: true,
      cancelable: true
    });
    this.clientX = base.clientX;
    this.clientY = base.clientY;
    this.screenX = base.screenX;
    this.screenY = base.screenY;
    this.button = base.button;
    this.buttons = base.buttons;
    this.ctrlKey = base.ctrlKey;
    this.altKey = base.altKey;
    this.shiftKey = base.shiftKey;
    this.metaKey = base.metaKey;
    this.relatedTarget = base.relatedTarget;
    this.movementX = base.movementX;
    this.movementY = base.movementY;
    this.offsetX = base.offsetX;
    this.offsetY = base.offsetY;
    this.pageX = base.pageX;
    this.pageY = base.pageY;
    this.x = base.x;
    this.y = base.y;
    this.getModifierState = (key) => base.getModifierState(key);
  }
};
var CustomKeyboardEvent = class extends CustomEvent {
  static {
    __name(this, "CustomKeyboardEvent");
  }
  constructor(name, detail, base) {
    super(name, {
      detail,
      bubbles: true,
      cancelable: true
    });
    this.altKey = base.altKey;
    this.charCode = base.charCode;
    this.code = base.code;
    this.ctrlKey = base.ctrlKey;
    this.isComposing = base.isComposing;
    this.key = base.key;
    this.keyCode = base.keyCode;
    this.location = base.location;
    this.metaKey = base.metaKey;
    this.repeat = base.repeat;
    this.shiftKey = base.shiftKey;
    this.getModifierState = (key) => base.getModifierState(key);
  }
};
var CustomPointerEvent = class extends CustomEvent {
  static {
    __name(this, "CustomPointerEvent");
  }
  constructor(name, detail, base) {
    super(name, {
      detail,
      bubbles: true,
      cancelable: true
    });
    this.height = base.height;
    this.isPrimary = base.isPrimary;
    this.pointerId = base.pointerId;
    this.pointerType = base.pointerType;
    this.pressure = base.pressure;
    this.tangentialPressure = base.tangentialPressure;
    this.tiltX = base.tiltX;
    this.tiltY = base.tiltY;
    this.twist = base.twist;
    this.width = base.width;
    this.getCoalescedEvents = () => base.getCoalescedEvents();
    this.getPredictedEvents = () => base.getPredictedEvents();
  }
};

// src/utils/force-class-name.ts
var forceClassName = /* @__PURE__ */ __name((element, className) => {
  element.classList.add(className);
  element.observeAttribute("class");
  element.lifecycle.on(
    ElementLifecycleEvent.AttributeDidChange,
    (event) => {
      if (event.detail.attributeName === "class") {
        if (!element.classList.contains(className)) {
          element.classList.add(className);
        }
      }
    }
  );
}, "forceClassName");

// src/utils/fuzzy-search.ts
function fuzzyCmp(q, text) {
  const searchLength = q.length;
  const textLength = text.length;
  if (searchLength > textLength) {
    return false;
  }
  if (text.indexOf(q) >= 0) {
    return true;
  }
  mainLoop: for (let i = 0, j = 0; i < searchLength; i += 1) {
    const ch = q.charCodeAt(i);
    while (j < textLength) {
      if (text.charCodeAt(j++) === ch) {
        continue mainLoop;
      }
    }
    return false;
  }
  return true;
}
__name(fuzzyCmp, "fuzzyCmp");

// src/utils/get-uid.ts
var UID_LEN = 8;
var getUid = /* @__PURE__ */ __name(() => {
  const uid = Math.random().toString(36).substring(2, UID_LEN);
  return ":" + uid + ":";
}, "getUid");

// src/utils/prevent-default.ts
function preventDefault(event) {
  event.preventDefault();
}
__name(preventDefault, "preventDefault");
function stopEvent(event) {
  event.stopPropagation();
}
__name(stopEvent, "stopEvent");

// src/components/input/input.css
var stylesheet2 = "adw-input{position:relative;display:flex}adw-input input{width:100%}adw-input .input-msg-box{margin:.2em 0 0 .5em}adw-input .input-msg-box span{font-size:.7em}adw-input .suggestions-options{position:absolute;left:0;right:0;max-height:min(16em,80vh);overflow-y:scroll;font-size:.8em;z-index:10}adw-input .suggestions-options.orientation-down{top:calc(100% + .2em)}adw-input .suggestions-options.orientation-up{bottom:calc(100% + .2em)}adw-input .suggestions-options *{cursor:pointer}";
var exports2 = {
  css: stylesheet2,
  element: null
};
(function() {
  if (typeof window !== "undefined") {
    const head = document.head;
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(stylesheet2));
    head.appendChild(style);
    exports2.element = style;
  }
})();

// src/components/input/input.tsx
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var InputChangeEvent = class extends CustomEvent {
  static {
    __name(this, "InputChangeEvent");
  }
  constructor(type, value) {
    super("change", {
      detail: {
        value,
        type
      }
    });
  }
};
var ADWaveInputElement = (() => {
  let _classDecorators = [CustomElement("adw-input")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = BaseElement;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  let _name_decorators;
  let _name_initializers = [];
  let _name_extraInitializers = [];
  let _form_decorators;
  let _form_initializers = [];
  let _form_extraInitializers = [];
  let _type_decorators;
  let _type_initializers = [];
  let _type_extraInitializers = [];
  let _placeholder_decorators;
  let _placeholder_initializers = [];
  let _placeholder_extraInitializers = [];
  let _minLength_decorators;
  let _minLength_initializers = [];
  let _minLength_extraInitializers = [];
  let _maxLength_decorators;
  let _maxLength_initializers = [];
  let _maxLength_extraInitializers = [];
  let _errorLabel_decorators;
  let _errorLabel_initializers = [];
  let _errorLabel_extraInitializers = [];
  let _alertLabel_decorators;
  let _alertLabel_initializers = [];
  let _alertLabel_extraInitializers = [];
  let _suggestions_decorators;
  let _suggestions_initializers = [];
  let _suggestions_extraInitializers = [];
  let _suggestionsShowAll_decorators;
  let _suggestionsShowAll_initializers = [];
  let _suggestionsShowAll_extraInitializers = [];
  let _suggestionsOrientation_decorators;
  let _suggestionsOrientation_initializers = [];
  let _suggestionsOrientation_extraInitializers = [];
  let _fuzzy_decorators;
  let _fuzzy_initializers = [];
  let _fuzzy_extraInitializers = [];
  let _availableOptions_decorators;
  let _availableOptions_initializers = [];
  let _availableOptions_extraInitializers = [];
  let _selectedOption_decorators;
  let _selectedOption_initializers = [];
  let _selectedOption_extraInitializers = [];
  let _isSuggestionsOpen_decorators;
  let _isSuggestionsOpen_initializers = [];
  let _isSuggestionsOpen_extraInitializers = [];
  var ADWaveInputElement2 = class extends _classSuper {
    static {
      __name(this, "ADWaveInputElement");
    }
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _value_decorators = [Attribute2({ nullable: false })];
      _disabled_decorators = [Attribute2({ type: "boolean", nullable: false })];
      _name_decorators = [Attribute2({ nullable: true })];
      _form_decorators = [Attribute2({ nullable: true })];
      _type_decorators = [Attribute2({ nullable: true, default: "text" })];
      _placeholder_decorators = [Attribute2({ nullable: true })];
      _minLength_decorators = [Attribute2({ type: "number", nullable: true })];
      _maxLength_decorators = [Attribute2({ type: "number", nullable: true })];
      _errorLabel_decorators = [Attribute2({ nullable: true })];
      _alertLabel_decorators = [Attribute2({ nullable: true })];
      _suggestions_decorators = [Attribute2({ nullable: true })];
      _suggestionsShowAll_decorators = [Attribute2({ type: "boolean", nullable: false })];
      _suggestionsOrientation_decorators = [Attribute2({ nullable: true, default: "down" })];
      _fuzzy_decorators = [Attribute2({ type: "boolean", nullable: false })];
      _availableOptions_decorators = [State()];
      _selectedOption_decorators = [State()];
      _isSuggestionsOpen_decorators = [State()];
      __esDecorate(this, null, _value_decorators, { kind: "accessor", name: "value", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "value" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.value, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.value = value;
      }, "set") }, metadata: _metadata }, _value_initializers, _value_extraInitializers);
      __esDecorate(this, null, _disabled_decorators, { kind: "accessor", name: "disabled", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "disabled" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.disabled, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.disabled = value;
      }, "set") }, metadata: _metadata }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate(this, null, _name_decorators, { kind: "accessor", name: "name", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "name" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.name, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.name = value;
      }, "set") }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
      __esDecorate(this, null, _form_decorators, { kind: "accessor", name: "form", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "form" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.form, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.form = value;
      }, "set") }, metadata: _metadata }, _form_initializers, _form_extraInitializers);
      __esDecorate(this, null, _type_decorators, { kind: "accessor", name: "type", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "type" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.type, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.type = value;
      }, "set") }, metadata: _metadata }, _type_initializers, _type_extraInitializers);
      __esDecorate(this, null, _placeholder_decorators, { kind: "accessor", name: "placeholder", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "placeholder" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.placeholder, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.placeholder = value;
      }, "set") }, metadata: _metadata }, _placeholder_initializers, _placeholder_extraInitializers);
      __esDecorate(this, null, _minLength_decorators, { kind: "accessor", name: "minLength", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "minLength" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.minLength, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.minLength = value;
      }, "set") }, metadata: _metadata }, _minLength_initializers, _minLength_extraInitializers);
      __esDecorate(this, null, _maxLength_decorators, { kind: "accessor", name: "maxLength", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "maxLength" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.maxLength, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.maxLength = value;
      }, "set") }, metadata: _metadata }, _maxLength_initializers, _maxLength_extraInitializers);
      __esDecorate(this, null, _errorLabel_decorators, { kind: "accessor", name: "errorLabel", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "errorLabel" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.errorLabel, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.errorLabel = value;
      }, "set") }, metadata: _metadata }, _errorLabel_initializers, _errorLabel_extraInitializers);
      __esDecorate(this, null, _alertLabel_decorators, { kind: "accessor", name: "alertLabel", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "alertLabel" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.alertLabel, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.alertLabel = value;
      }, "set") }, metadata: _metadata }, _alertLabel_initializers, _alertLabel_extraInitializers);
      __esDecorate(this, null, _suggestions_decorators, { kind: "accessor", name: "suggestions", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "suggestions" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.suggestions, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.suggestions = value;
      }, "set") }, metadata: _metadata }, _suggestions_initializers, _suggestions_extraInitializers);
      __esDecorate(this, null, _suggestionsShowAll_decorators, { kind: "accessor", name: "suggestionsShowAll", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "suggestionsShowAll" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.suggestionsShowAll, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.suggestionsShowAll = value;
      }, "set") }, metadata: _metadata }, _suggestionsShowAll_initializers, _suggestionsShowAll_extraInitializers);
      __esDecorate(this, null, _suggestionsOrientation_decorators, { kind: "accessor", name: "suggestionsOrientation", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "suggestionsOrientation" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.suggestionsOrientation, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.suggestionsOrientation = value;
      }, "set") }, metadata: _metadata }, _suggestionsOrientation_initializers, _suggestionsOrientation_extraInitializers);
      __esDecorate(this, null, _fuzzy_decorators, { kind: "accessor", name: "fuzzy", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "fuzzy" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.fuzzy, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.fuzzy = value;
      }, "set") }, metadata: _metadata }, _fuzzy_initializers, _fuzzy_extraInitializers);
      __esDecorate(this, null, _availableOptions_decorators, { kind: "accessor", name: "availableOptions", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "availableOptions" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.availableOptions, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.availableOptions = value;
      }, "set") }, metadata: _metadata }, _availableOptions_initializers, _availableOptions_extraInitializers);
      __esDecorate(this, null, _selectedOption_decorators, { kind: "accessor", name: "selectedOption", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "selectedOption" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.selectedOption, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.selectedOption = value;
      }, "set") }, metadata: _metadata }, _selectedOption_initializers, _selectedOption_extraInitializers);
      __esDecorate(this, null, _isSuggestionsOpen_decorators, { kind: "accessor", name: "isSuggestionsOpen", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "isSuggestionsOpen" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.isSuggestionsOpen, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.isSuggestionsOpen = value;
      }, "set") }, metadata: _metadata }, _isSuggestionsOpen_initializers, _isSuggestionsOpen_extraInitializers);
      __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      ADWaveInputElement2 = _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    #value_accessor_storage;
    get value() {
      return this.#value_accessor_storage;
    }
    set value(value) {
      this.#value_accessor_storage = value;
    }
    #disabled_accessor_storage;
    get disabled() {
      return this.#disabled_accessor_storage;
    }
    set disabled(value) {
      this.#disabled_accessor_storage = value;
    }
    #name_accessor_storage;
    get name() {
      return this.#name_accessor_storage;
    }
    set name(value) {
      this.#name_accessor_storage = value;
    }
    #form_accessor_storage;
    get form() {
      return this.#form_accessor_storage;
    }
    set form(value) {
      this.#form_accessor_storage = value;
    }
    #type_accessor_storage;
    get type() {
      return this.#type_accessor_storage;
    }
    set type(value) {
      this.#type_accessor_storage = value;
    }
    #placeholder_accessor_storage;
    get placeholder() {
      return this.#placeholder_accessor_storage;
    }
    set placeholder(value) {
      this.#placeholder_accessor_storage = value;
    }
    #minLength_accessor_storage;
    get minLength() {
      return this.#minLength_accessor_storage;
    }
    set minLength(value) {
      this.#minLength_accessor_storage = value;
    }
    #maxLength_accessor_storage;
    get maxLength() {
      return this.#maxLength_accessor_storage;
    }
    set maxLength(value) {
      this.#maxLength_accessor_storage = value;
    }
    #errorLabel_accessor_storage;
    get errorLabel() {
      return this.#errorLabel_accessor_storage;
    }
    set errorLabel(value) {
      this.#errorLabel_accessor_storage = value;
    }
    #alertLabel_accessor_storage;
    get alertLabel() {
      return this.#alertLabel_accessor_storage;
    }
    set alertLabel(value) {
      this.#alertLabel_accessor_storage = value;
    }
    #suggestions_accessor_storage;
    get suggestions() {
      return this.#suggestions_accessor_storage;
    }
    set suggestions(value) {
      this.#suggestions_accessor_storage = value;
    }
    #suggestionsShowAll_accessor_storage;
    get suggestionsShowAll() {
      return this.#suggestionsShowAll_accessor_storage;
    }
    set suggestionsShowAll(value) {
      this.#suggestionsShowAll_accessor_storage = value;
    }
    #suggestionsOrientation_accessor_storage;
    get suggestionsOrientation() {
      return this.#suggestionsOrientation_accessor_storage;
    }
    set suggestionsOrientation(value) {
      this.#suggestionsOrientation_accessor_storage = value;
    }
    #fuzzy_accessor_storage;
    get fuzzy() {
      return this.#fuzzy_accessor_storage;
    }
    set fuzzy(value) {
      this.#fuzzy_accessor_storage = value;
    }
    #availableOptions_accessor_storage;
    get availableOptions() {
      return this.#availableOptions_accessor_storage;
    }
    set availableOptions(value) {
      this.#availableOptions_accessor_storage = value;
    }
    #selectedOption_accessor_storage;
    get selectedOption() {
      return this.#selectedOption_accessor_storage;
    }
    set selectedOption(value) {
      this.#selectedOption_accessor_storage = value;
    }
    #isSuggestionsOpen_accessor_storage;
    get isSuggestionsOpen() {
      return this.#isSuggestionsOpen_accessor_storage;
    }
    set isSuggestionsOpen(value) {
      this.#isSuggestionsOpen_accessor_storage = value;
    }
    constructor() {
      super();
      this.#value_accessor_storage = __runInitializers(this, _value_initializers, "");
      this.#disabled_accessor_storage = (__runInitializers(this, _value_extraInitializers), __runInitializers(this, _disabled_initializers, false));
      this.#name_accessor_storage = (__runInitializers(this, _disabled_extraInitializers), __runInitializers(this, _name_initializers, null));
      this.#form_accessor_storage = (__runInitializers(this, _name_extraInitializers), __runInitializers(this, _form_initializers, null));
      this.#type_accessor_storage = (__runInitializers(this, _form_extraInitializers), __runInitializers(this, _type_initializers, "text"));
      this.#placeholder_accessor_storage = (__runInitializers(this, _type_extraInitializers), __runInitializers(this, _placeholder_initializers, null));
      this.#minLength_accessor_storage = (__runInitializers(this, _placeholder_extraInitializers), __runInitializers(this, _minLength_initializers, null));
      this.#maxLength_accessor_storage = (__runInitializers(this, _minLength_extraInitializers), __runInitializers(this, _maxLength_initializers, null));
      this.#errorLabel_accessor_storage = (__runInitializers(this, _maxLength_extraInitializers), __runInitializers(this, _errorLabel_initializers, null));
      this.#alertLabel_accessor_storage = (__runInitializers(this, _errorLabel_extraInitializers), __runInitializers(this, _alertLabel_initializers, null));
      this.#suggestions_accessor_storage = (__runInitializers(this, _alertLabel_extraInitializers), __runInitializers(this, _suggestions_initializers, null));
      this.#suggestionsShowAll_accessor_storage = (__runInitializers(this, _suggestions_extraInitializers), __runInitializers(this, _suggestionsShowAll_initializers, false));
      this.#suggestionsOrientation_accessor_storage = (__runInitializers(this, _suggestionsShowAll_extraInitializers), __runInitializers(this, _suggestionsOrientation_initializers, "down"));
      this.#fuzzy_accessor_storage = (__runInitializers(this, _suggestionsOrientation_extraInitializers), __runInitializers(this, _fuzzy_initializers, false));
      this.#availableOptions_accessor_storage = (__runInitializers(this, _fuzzy_extraInitializers), __runInitializers(this, _availableOptions_initializers, []));
      this.#selectedOption_accessor_storage = (__runInitializers(this, _availableOptions_extraInitializers), __runInitializers(this, _selectedOption_initializers, -1));
      this.#isSuggestionsOpen_accessor_storage = (__runInitializers(this, _selectedOption_extraInitializers), __runInitializers(this, _isSuggestionsOpen_initializers, false));
      this.uid = (__runInitializers(this, _isSuggestionsOpen_extraInitializers), getUid());
      this.isInFocus = false;
      this.hasChanged = false;
      this.lastScrollIntoView = 0;
      this.handleOptionClick = (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        const target = ev.target;
        const idx = target.dataset.opt ? Number(target.dataset.opt) : void 0;
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("optionclick", {
          option: idx ? this.availableOptions[idx] : ""
        }, ev));
        if (idx != null && shouldContinue) {
          this.value = this.availableOptions[idx] ?? "";
          this.isSuggestionsOpen = false;
        }
      };
      this.handleInputChange = (ev) => {
        const inputElem = ev.target;
        this.value = inputElem.value;
      };
      this.handleKeyDown = (ev) => {
        switch (ev.key) {
          case "ArrowUp":
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                if (this.suggestionsOrientation == "up") {
                  this.highlightPreviousOption();
                } else {
                  this.highlightNextOption();
                }
              }
            });
            break;
          case "ArrowDown":
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                if (this.suggestionsOrientation == "up") {
                  this.highlightNextOption();
                } else {
                  this.highlightPreviousOption();
                }
              }
            });
            break;
          case "PageUp":
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                if (this.suggestionsOrientation == "up") {
                  this.highlightPreviousOption(8);
                } else {
                  this.highlightNextOption(8);
                }
              }
            });
            break;
          case "PageDown":
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                if (this.suggestionsOrientation == "up") {
                  this.highlightNextOption(8);
                } else {
                  this.highlightPreviousOption(8);
                }
              }
            });
            break;
          case "Home":
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                if (this.suggestionsOrientation == "up") {
                  this.highlightPreviousOption(this.availableOptions.length - 1);
                } else {
                  this.highlightNextOption(this.availableOptions.length - 1);
                }
              }
            });
            break;
          case "End":
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                if (this.suggestionsOrientation == "up") {
                  this.highlightNextOption(this.availableOptions.length - 1);
                } else {
                  this.highlightPreviousOption(this.availableOptions.length - 1);
                }
              }
            });
            break;
          case "Enter":
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen && this.selectedOption >= 0) {
                ev.preventDefault();
                const opt = this.availableOptions[this.selectedOption];
                if (opt) {
                  this.value = opt;
                  this.isSuggestionsOpen = false;
                  this.dispatchEvent(new InputChangeEvent("select", this.value));
                }
              } else if (this.hasChanged) {
                this.hasChanged = false;
                this.dispatchEvent(new InputChangeEvent("submit", this.value));
              }
            }, () => {
              ev.preventDefault();
            });
            break;
          case "Backspace":
            this.withCustomKeyEvent(ev, () => {
              this.isSuggestionsOpen = true;
            }, () => {
              ev.preventDefault();
            });
            break;
          case "Escape":
            this.withCustomKeyEvent(ev, () => {
              if (this.isSuggestionsOpen) {
                this.isSuggestionsOpen = false;
              }
            }, () => {
              ev.preventDefault();
            });
            break;
        }
      };
      this.handleFocus = (ev) => {
        this.isInFocus = true;
        if (this.availableOptions.length) {
          this.isSuggestionsOpen = true;
        }
      };
      this.handleBlur = (ev) => {
        this.isInFocus = false;
        this.isSuggestionsOpen = false;
        if (this.hasChanged) {
          this.hasChanged = false;
          this.dispatchEvent(new InputChangeEvent("submit", this.value));
        }
      };
      this.Suggestions = () => {
        const isHidden = this.suggestions == null || this.availableOptions.length === 0 || this.isSuggestionsOpen === false;
        const reversed = this.suggestionsOrientation == "up";
        const options = this.availableOptions.map((option, idx) => {
          const isActive = idx === this.selectedOption;
          return jsx("div", { "data-opt": idx, class: cls({
            [Suggestions.option]: true,
            [Suggestions.active]: isActive
          }), onclick: this.handleOptionClick, onmousedown: preventDefault, role: "option", children: jsx("span", { "data-opt": idx, class: "text", children: option }) });
        });
        if (reversed) {
          options.reverse();
        }
        return jsx("div", { id: this.uid, class: cls([
          {
            [Suggestions.suggestions]: true,
            "suggestions-options": true,
            _adw_hidden: isHidden
          },
          this.suggestionsOrientation === "up" ? ["orientation-up", "top"] : "orientation-down"
        ]), role: "listbox", children: options });
      };
      this.immediateEffect(() => {
        this.availableOptions = this.getMatchingOptions();
        this.selectedOption = -1;
      }, (s) => [s.value, s.suggestions, s.suggestionsShowAll]);
      this.immediateEffect(() => {
        if (this.isSuggestionsOpen) {
          this.selectedOption = -1;
        }
      }, (s) => [s.isSuggestionsOpen]);
      this.effect(() => {
        if (this.isSuggestionsOpen) {
          this.scrollActiveToView();
        }
      }, (s) => [s.selectedOption]);
      this.effect(() => {
        if (this.isSuggestionsOpen) {
          this.scrollActiveToView(true);
        }
      }, (s) => [s.isSuggestionsOpen]);
      this.effect(({ isFirstMount }) => {
        if (isFirstMount)
          return;
        if (this.isInFocus) {
          this.hasChanged = true;
        } else {
          this.dispatchEvent(new InputChangeEvent("submit", this.value));
        }
      }, (s) => [s.value]);
      this.lifecycle.once(ElementLifecycleEvent.WillMount, () => {
        forceClassName(this, Input.wrapper);
      });
    }
    /**
     * Performs a simple search through options with the provided query,
     * if the option starts with the exact same string as the query, it
     * is considered a match.
     */
    search(options, query) {
      const results = [];
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        if (option.toLowerCase().startsWith(query)) {
          results.push(option);
        }
      }
      return results;
    }
    /**
     * Performs a fuzzy search through options with the provided query,
     * if the option is similar enough to the query, it is considered a
     * match.
     */
    fuzzySearch(options, query) {
      const results = [];
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        if (fuzzyCmp(query, option.toLowerCase())) {
          results.push(option);
        }
      }
      return results;
    }
    getMatchingOptions() {
      if (this.suggestions == null) {
        return [];
      }
      let options = this.suggestions.split(";");
      if (this.suggestionsShowAll) {
        return options;
      }
      const value = this.value?.toLowerCase();
      if (value == null) {
        return options;
      }
      if (this.fuzzy) {
        return this.fuzzySearch(options, value);
      } else {
        return this.search(options, value);
      }
    }
    /** Scrolls into view the currently highlighted suggestion. */
    scrollActiveToView(forceInstant = false) {
      const suggestions = this.querySelector(`.${Suggestions.suggestions}`);
      if (suggestions == null) {
        return;
      }
      const activeOption = suggestions?.querySelector(`.${Suggestions.active}`);
      if (activeOption == null) {
        return;
      }
      const now = Date.now();
      if (forceInstant || now - this.lastScrollIntoView <= 100) {
        activeOption.scrollIntoView({
          behavior: "instant",
          block: "nearest"
        });
      } else {
        activeOption.scrollIntoView({
          behavior: "smooth",
          block: "nearest"
        });
      }
      this.lastScrollIntoView = now;
    }
    highlightNextOption(offset = 1) {
      this.selectedOption = Math.max(-1, this.selectedOption - offset);
    }
    highlightPreviousOption(offset = 1) {
      this.selectedOption = Math.min(this.availableOptions.length - 1, this.selectedOption + offset);
    }
    withCustomKeyEvent(ev, cb, onCancel) {
      ev.stopPropagation();
      const shouldContinue = this.dispatchEvent(new CustomKeyboardEvent("keydown", {}, ev));
      if (shouldContinue) {
        cb();
      } else if (onCancel) {
        onCancel();
      }
    }
    render() {
      return jsxs(Fragment, { children: [jsx("input", { class: cls({
        [Input.input]: true,
        [Input.disabled]: this.disabled
      }), oninput: this.handleInputChange, onkeydown: this.handleKeyDown, onfocus: this.handleFocus, onblur: this.handleBlur, onchange: stopEvent, type: this.type, value: this.value ?? void 0, disabled: this.disabled, name: this.name ?? void 0, form: this.form ?? void 0, placeholder: this.placeholder ?? void 0, minlength: this.minLength ?? void 0, maxlength: this.maxLength ?? void 0, "aria-placeholder": this.placeholder, "aria-label": this.placeholder, "aria-invalid": this.errorLabel != null, "aria-haspopup": "listbox", "aria-expanded": this.isSuggestionsOpen, "aria-controls": this.uid }), jsx(this.Suggestions, {})] });
    }
  };
  return ADWaveInputElement2 = _classThis;
})();

// src/components/selector/selector.css
var stylesheet3 = "adw-selector{display:flex}adw-selector .selector{flex:1}adw-selector .selector .option:not(.inert):focus{background-color:rgb(255 255 255/15%)!important}adw-selector .selector .option.selected{background-color:rgb(255 255 255/20%)!important}adw-selector .selected-option{text-wrap:nowrap}adw-selector .selected-option.with-placeholder{opacity:.4}adw-selector .selector .options-list{display:none;z-index:10;max-height:min(20em,80vh);overflow-y:scroll}adw-selector .selector .options-list .option.inert,adw-selector dialog[open]{display:flex;justify-content:center;align-items:center}adw-selector .selector .options-list .option.inert span{color:var(--clr-text-secondary)}adw-selector .selector .options-list .option.inert span.opt-label{margin-inline:.5em}adw-selector .selector .options-list .option.inert span:is(:first-child,:last-child){flex:1;height:1px;background-color:var(--clr-text-secondary)}adw-selector .selector .options-list .option.inert:hover{background-color:initial}adw-selector .selector.opened .options-list{display:flex}adw-selector dialog{border:unset;margin:unset;background:0 0;width:100%;height:100%;overflow:hidden}adw-selector dialog::backdrop{background-color:rgb(35 35 35/50%)}adw-selector .selector dialog .options-list{margin:unset;padding:.4em;width:calc(95% - .8em);max-height:calc(85% - .8em);font-size:1.25em}adw-selector .selector dialog .options-list .option{padding:.5em}";
var exports3 = {
  css: stylesheet3,
  element: null
};
(function() {
  if (typeof window !== "undefined") {
    const head = document.head;
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(stylesheet3));
    head.appendChild(style);
    exports3.element = style;
  }
})();

// src/components/selector/selector.tsx
var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
var SEARCHABLE_CHARS = `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+=-[]\\{}|;':",./<>?`.split("");
var FOCUS_CHANGE_EVENT_THROTTLE = 60;
var SelectorChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SelectorChangeEvent");
  }
  constructor(value) {
    super("change", {
      detail: {
        value
      }
    });
  }
};
var ADWaveSelector = (() => {
  let _classDecorators = [CustomElement("adw-selector")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = BaseElement;
  let _placeholder_decorators;
  let _placeholder_initializers = [];
  let _placeholder_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  let _name_decorators;
  let _name_initializers = [];
  let _name_extraInitializers = [];
  let _form_decorators;
  let _form_initializers = [];
  let _form_extraInitializers = [];
  let _orientation_decorators;
  let _orientation_initializers = [];
  let _orientation_extraInitializers = [];
  let _reverseorder_decorators;
  let _reverseorder_initializers = [];
  let _reverseorder_extraInitializers = [];
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _isOpen_decorators;
  let _isOpen_initializers = [];
  let _isOpen_extraInitializers = [];
  let _options_decorators;
  let _options_initializers = [];
  let _options_extraInitializers = [];
  var ADWaveSelector2 = class extends _classSuper {
    static {
      __name(this, "ADWaveSelector");
    }
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _placeholder_decorators = [Attribute2({ nullable: true })];
      _disabled_decorators = [Attribute2({ type: "boolean", nullable: false, default: false })];
      _name_decorators = [Attribute2({ nullable: true })];
      _form_decorators = [Attribute2({ nullable: true })];
      _orientation_decorators = [Attribute2({ nullable: false, default: "down" })];
      _reverseorder_decorators = [Attribute2({ type: "boolean", nullable: false, default: false })];
      _value_decorators = [Attribute2({ nullable: true })];
      _isOpen_decorators = [State()];
      _options_decorators = [Slotted({ filter: "adw-option" })];
      __esDecorate2(this, null, _placeholder_decorators, { kind: "accessor", name: "placeholder", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "placeholder" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.placeholder, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.placeholder = value;
      }, "set") }, metadata: _metadata }, _placeholder_initializers, _placeholder_extraInitializers);
      __esDecorate2(this, null, _disabled_decorators, { kind: "accessor", name: "disabled", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "disabled" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.disabled, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.disabled = value;
      }, "set") }, metadata: _metadata }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate2(this, null, _name_decorators, { kind: "accessor", name: "name", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "name" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.name, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.name = value;
      }, "set") }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
      __esDecorate2(this, null, _form_decorators, { kind: "accessor", name: "form", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "form" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.form, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.form = value;
      }, "set") }, metadata: _metadata }, _form_initializers, _form_extraInitializers);
      __esDecorate2(this, null, _orientation_decorators, { kind: "accessor", name: "orientation", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "orientation" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.orientation, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.orientation = value;
      }, "set") }, metadata: _metadata }, _orientation_initializers, _orientation_extraInitializers);
      __esDecorate2(this, null, _reverseorder_decorators, { kind: "accessor", name: "reverseorder", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "reverseorder" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.reverseorder, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.reverseorder = value;
      }, "set") }, metadata: _metadata }, _reverseorder_initializers, _reverseorder_extraInitializers);
      __esDecorate2(this, null, _value_decorators, { kind: "accessor", name: "value", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "value" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.value, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.value = value;
      }, "set") }, metadata: _metadata }, _value_initializers, _value_extraInitializers);
      __esDecorate2(this, null, _isOpen_decorators, { kind: "accessor", name: "isOpen", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "isOpen" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.isOpen, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.isOpen = value;
      }, "set") }, metadata: _metadata }, _isOpen_initializers, _isOpen_extraInitializers);
      __esDecorate2(this, null, _options_decorators, { kind: "accessor", name: "options", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "options" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.options, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.options = value;
      }, "set") }, metadata: _metadata }, _options_initializers, _options_extraInitializers);
      __esDecorate2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      ADWaveSelector2 = _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers2(_classThis, _classExtraInitializers);
    }
    #placeholder_accessor_storage;
    get placeholder() {
      return this.#placeholder_accessor_storage;
    }
    set placeholder(value) {
      this.#placeholder_accessor_storage = value;
    }
    #disabled_accessor_storage;
    get disabled() {
      return this.#disabled_accessor_storage;
    }
    set disabled(value) {
      this.#disabled_accessor_storage = value;
    }
    #name_accessor_storage;
    get name() {
      return this.#name_accessor_storage;
    }
    set name(value) {
      this.#name_accessor_storage = value;
    }
    #form_accessor_storage;
    get form() {
      return this.#form_accessor_storage;
    }
    set form(value) {
      this.#form_accessor_storage = value;
    }
    #orientation_accessor_storage;
    get orientation() {
      return this.#orientation_accessor_storage;
    }
    set orientation(value) {
      this.#orientation_accessor_storage = value;
    }
    #reverseorder_accessor_storage;
    get reverseorder() {
      return this.#reverseorder_accessor_storage;
    }
    set reverseorder(value) {
      this.#reverseorder_accessor_storage = value;
    }
    #value_accessor_storage;
    get value() {
      return this.#value_accessor_storage;
    }
    set value(value) {
      this.#value_accessor_storage = value;
    }
    #isOpen_accessor_storage;
    get isOpen() {
      return this.#isOpen_accessor_storage;
    }
    set isOpen(value) {
      this.#isOpen_accessor_storage = value;
    }
    #options_accessor_storage;
    get options() {
      return this.#options_accessor_storage;
    }
    set options(value) {
      this.#options_accessor_storage = value;
    }
    constructor() {
      super();
      this.#placeholder_accessor_storage = __runInitializers2(this, _placeholder_initializers, null);
      this.#disabled_accessor_storage = (__runInitializers2(this, _placeholder_extraInitializers), __runInitializers2(this, _disabled_initializers, false));
      this.#name_accessor_storage = (__runInitializers2(this, _disabled_extraInitializers), __runInitializers2(this, _name_initializers, null));
      this.#form_accessor_storage = (__runInitializers2(this, _name_extraInitializers), __runInitializers2(this, _form_initializers, null));
      this.#orientation_accessor_storage = (__runInitializers2(this, _form_extraInitializers), __runInitializers2(this, _orientation_initializers, "down"));
      this.#reverseorder_accessor_storage = (__runInitializers2(this, _orientation_extraInitializers), __runInitializers2(this, _reverseorder_initializers, false));
      this.#value_accessor_storage = (__runInitializers2(this, _reverseorder_extraInitializers), __runInitializers2(this, _value_initializers, null));
      this.#isOpen_accessor_storage = (__runInitializers2(this, _value_extraInitializers), __runInitializers2(this, _isOpen_initializers, false));
      this.#options_accessor_storage = (__runInitializers2(this, _isOpen_extraInitializers), __runInitializers2(this, _options_initializers, []));
      this.selectableOptions = (__runInitializers2(this, _options_extraInitializers), []);
      this.uid = getUid();
      this.dialogElem = { current: null };
      this.optionsListElem = { current: null };
      this.searchInputMemory = "";
      this.handleClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {
          type: "selector"
        }, e));
        if (!shouldContinue || this.disabled) {
          return;
        }
        this.toggleOpen();
      };
      this.handleDialogClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const dialog = this.dialogElem.current;
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {
          type: "dialog"
        }, e));
        if (this.isOpen && dialog && shouldContinue) {
          if (!this.optionsListElem.current?.contains(e.target)) {
            dialog.close();
            this.isOpen = false;
          }
        }
      };
      this.handleOptionClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const btn = e.target;
        const { option: optValue } = btn?.dataset ?? {};
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {
          type: "option",
          option: optValue
        }, e));
        if (!shouldContinue || this.disabled || optValue == null) {
          return;
        }
        const success = this.select(optValue);
        if (success) {
          const dialog = this.dialogElem.current;
          dialog?.close();
          this.isOpen = false;
          this.focusSelf();
        }
      };
      this.handleModalCancel = (e) => {
        this.isOpen = false;
      };
      this._lastFocusChange = 0;
      this.handleKeyDown = (ev) => {
        if (this.disabled) {
          return;
        }
        switch (ev.key) {
          case " ":
          case "Enter": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (!this.isOpen) {
                this.dialogElem.current?.showModal();
                this.isOpen = true;
              } else {
                const target = ev.target;
                if (target.tagName === "BUTTON") {
                  if (ev.key === "Enter")
                    target.click();
                } else {
                  this.dialogElem.current?.close();
                  this.isOpen = false;
                }
              }
            });
            break;
          }
          case "ArrowUp": {
            ev.preventDefault();
            this.withFocusChangeEvent(() => {
              this.withCustomKeyEvent(ev, () => {
                this.focusOption(-1);
              });
            });
            break;
          }
          case "ArrowDown": {
            ev.preventDefault();
            this.withFocusChangeEvent(() => {
              this.withCustomKeyEvent(ev, () => {
                this.focusOption(1);
              });
            });
            break;
          }
          case "PageUp": {
            ev.preventDefault();
            this.withFocusChangeEvent(() => {
              this.withCustomKeyEvent(ev, () => {
                this.focusOption(-10);
              });
            });
            break;
          }
          case "PageDown": {
            ev.preventDefault();
            this.withFocusChangeEvent(() => {
              this.withCustomKeyEvent(ev, () => {
                this.focusOption(10);
              });
            });
            break;
          }
          case "Home": {
            ev.preventDefault();
            this.withFocusChangeEvent(() => {
              this.withCustomKeyEvent(ev, () => {
                this.focusOption(-this.selectableOptions.length);
              });
            });
            break;
          }
          case "End": {
            ev.preventDefault();
            this.withFocusChangeEvent(() => {
              this.withCustomKeyEvent(ev, () => {
                this.focusOption(+this.selectableOptions.length);
              });
            });
            break;
          }
          case "Escape": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isOpen) {
                this.isOpen = false;
                this.focusSelf();
              }
            });
            break;
          }
          default:
            if (SEARCHABLE_CHARS.includes(ev.key)) {
              this.searchInputMemory += ev.key;
              window.clearTimeout(this.clearSearchInputMemoryTimeout);
              this.clearSearchInputMemoryTimeout = window.setTimeout(() => {
                this.searchInputMemory = "";
              }, 1e3);
              this.tryInputSearch();
            }
            break;
        }
      };
      this.Option = (props) => {
        const isSelected = props.option.isEqualTo(this.value);
        const isInert = props.option.inert;
        if (isInert) {
          return jsxs("button", { class: cls([{
            [Selector.option]: true,
            inert: true
          }, props.option.className]), role: "presentation", onclick: stopEvent, children: [jsx("span", {}), jsx("span", { class: "opt-label", children: props.option.getLabel() }), jsx("span", {})] });
        }
        return jsx("button", { class: cls([{
          [Selector.option]: true,
          selected: isSelected
        }, props.option.className]), onclick: this.handleOptionClick, "data-option": props.option.getValue(), role: "option", "aria-selected": isSelected, children: props.option.getLabel() });
      };
      this.OptionsListMobile = () => {
        let options = this.options;
        if (this.reverseorder) {
          options = options.slice().reverse();
        }
        return jsx("dialog", { ref: this.dialogElem, onclick: this.handleDialogClick, oncancel: this.handleModalCancel, children: jsx("div", { id: this.uid, class: cls([Selector.optionsList, Selector.noPosition]), ref: this.optionsListElem, role: "listbox", children: options.map((option) => jsx(this.Option, { option })) }) });
      };
      this.OptionsListDesktop = () => {
        let options = this.options;
        if (this.reverseorder) {
          options = options.slice().reverse();
        }
        return jsx("div", { id: this.uid, class: cls({
          [Selector.optionsList]: true,
          [Selector.top]: this.orientation === "up"
        }), ref: this.optionsListElem, children: options.map((option) => jsx(this.Option, { option })) });
      };
      this.HiddenSelect = () => {
        return jsx("select", { class: "_adw_hidden", name: this.name ?? void 0, form: this.form ?? void 0, disabled: this.disabled ?? void 0, "aria-hidden": "true", onchange: stopEvent, children: this.selectableOptions.map((option, index) => {
          return jsx("option", { value: option.getValue(), selected: option.isEqualTo(this.value) });
        }) });
      };
      this.immediateEffect(() => {
        this.updateSelectableOptions();
      }, (s) => [s.options]);
      this.effect(() => {
        if (this.isOpen) {
          const optionsList = this.optionsListElem.current;
          if (optionsList) {
            const reverse = this.orientation === "up";
            if (this.value != null) {
              this.scrollToOption(this.value);
            } else {
              optionsList.scrollTo({
                top: reverse ? optionsList.scrollHeight : 0,
                behavior: "instant"
              });
            }
          }
          if (!IS_MOBILE) {
            const eventHandler = /* @__PURE__ */ __name((event) => {
              if (!this.contains(event.target)) {
                this.isOpen = false;
                this.dialogElem.current?.close();
              }
            }, "eventHandler");
            document.addEventListener("click", eventHandler);
            return () => {
              document.removeEventListener("click", eventHandler);
            };
          }
        }
      }, (s) => [s.isOpen]);
      this.effect(() => {
        const firstSelected = this.selectableOptions.find((opt) => opt.isSelected());
        if (firstSelected) {
          this.value = firstSelected.getValue();
          for (let j = 0; j < this.selectableOptions.length; j++) {
            const slot = this.selectableOptions[j];
            if (slot !== firstSelected) {
              slot.setSelected(false);
            }
          }
        }
      }, () => []);
      this.lifecycle.on(ElementLifecycleEvent.SlotDidChange, (c) => {
        if (c.detail.slotName === "options") {
          let hasChanged = false;
          const addedSlots = c.detail.changes.added;
          const removedSlots = c.detail.changes.removed;
          const changedSlots = c.detail.changes.attributeChanged;
          for (let i = 0; i < removedSlots.length; i++) {
            const slot = removedSlots[i];
            if (slot.isSelected()) {
              hasChanged = true;
              this.value = null;
            }
          }
          for (let i = 0; i < changedSlots.length; i++) {
            const slot = changedSlots[i];
            if (slot.isSelected()) {
              const newValue = slot.getValue();
              hasChanged = this.value !== newValue;
              this.value = newValue;
              for (let j = 0; j < this.selectableOptions.length; j++) {
                const otherSlot = this.selectableOptions[j];
                if (otherSlot !== slot) {
                  otherSlot.setSelected(false);
                }
              }
              break;
            }
          }
          for (let i = 0; i < addedSlots.length; i++) {
            const slot = addedSlots[i];
            if (slot.isSelected()) {
              const newValue = slot.getValue();
              hasChanged = this.value !== newValue;
              this.value = newValue;
              for (let j = 0; j < this.options.length; j++) {
                const otherSlot = this.options[j];
                if (otherSlot !== slot) {
                  otherSlot.setSelected(false);
                }
              }
              break;
            }
          }
          this.updateSelectableOptions();
          if (hasChanged) {
            this.dispatchEvent(new SelectorChangeEvent(this.value));
          }
        }
      });
    }
    toggleOpen() {
      if (!this.isOpen) {
        this.dialogElem.current?.showModal();
        this.isOpen = true;
      } else {
        this.dialogElem.current?.close();
        this.isOpen = false;
      }
    }
    updateSelectableOptions() {
      const selectedBefore = this.selectableOptions.find((o) => o.isSelected());
      this.selectableOptions = [];
      for (let i = 0; i < this.options.length; i++) {
        const option = this.options[i];
        if (!option.inert) {
          this.selectableOptions.push(option);
        }
      }
      if (selectedBefore) {
        const selectedAfter = this.selectableOptions.find((o) => o.isEqualTo(selectedBefore.getValue()));
        if (selectedAfter) {
          selectedBefore.setSelected(true);
        } else {
          this.value = null;
        }
      }
    }
    tryInputSearch() {
      if (this.searchInputMemory.length === 0)
        return;
      const searchTerm = this.searchInputMemory.toLowerCase();
      let foundOpt = this.selectableOptions.find((opt) => {
        const label = opt.getLabel().toLowerCase();
        return label.startsWith(searchTerm);
      });
      if (!foundOpt) {
        this.selectableOptions.find((opt) => {
          const label = opt.getLabel().toLowerCase();
          return label.includes(searchTerm);
        });
      }
      if (foundOpt) {
        this.scrollToOption(foundOpt?.getValue(), "smooth");
      }
    }
    scrollToOption(value, behavior = "instant") {
      const optionsList = this.optionsListElem.current;
      if (!optionsList) {
        return;
      }
      const allOptElems = Array.from(optionsList.querySelectorAll("button.option"));
      const activeOptionElem = allOptElems.find((btn) => btn.dataset.option === value);
      if (activeOptionElem) {
        const optionsList2 = this.optionsListElem.current;
        optionsList2?.scrollTo({
          top: activeOptionElem.offsetTop - optionsList2.clientHeight / 2,
          behavior
        });
        activeOptionElem.focus();
      }
    }
    focusSelf() {
      this.querySelector(`.${Selector.selector}`)?.focus();
    }
    /**
     * Selects the option that is offset from the currently focused
     * option. (e.g. focusOption(1) should select the option following
     * the currently focused one whereas focusOption(-2) should select
     * the second option that's behind the focused option)
     */
    focusOption(offset) {
      const options = this.optionsListElem.current;
      if (!options) {
        return;
      }
      let currentOption = options.querySelector(`.${Selector.option}:focus`);
      if (!currentOption) {
        currentOption = options.querySelector(`.${Selector.option}.selected`);
      }
      if (!currentOption) {
        const reverse = this.orientation === "up";
        const firstOption = options.querySelector(reverse ? `.${Selector.option}:nth-last-child(1 of :not(.inert))` : `.${Selector.option}:nth-child(1 of :not(.inert))`);
        firstOption?.focus();
        return;
      }
      let target = currentOption;
      const direction = offset > 0 ? "nextElementSibling" : "previousElementSibling";
      mainloop: for (let i = 0; i < Math.abs(offset); i++) {
        let next = target[direction];
        if (!next) {
          break;
        }
        while (next.classList.contains("inert")) {
          next = next[direction];
          if (!next) {
            break mainloop;
          }
        }
        target = next;
      }
      if (target) {
        target.focus();
      }
    }
    select(optionValue) {
      if (optionValue == null) {
        return false;
      }
      let success = false;
      for (let i = 0; i < this.selectableOptions.length; i++) {
        const option = this.selectableOptions[i];
        const isSelected = option.isEqualTo(optionValue);
        if (isSelected) {
          option.setSelected(true);
          success = true;
        }
      }
      return success;
    }
    withCustomKeyEvent(ev, cb, onCancel) {
      ev.stopPropagation();
      const shouldContinue = this.dispatchEvent(new CustomKeyboardEvent("keydown", {}, ev));
      if (shouldContinue) {
        cb();
      } else if (onCancel) {
        onCancel();
      }
    }
    withFocusChangeEvent(handler) {
      const now = Date.now();
      if (now - this._lastFocusChange > FOCUS_CHANGE_EVENT_THROTTLE) {
        this._lastFocusChange = now;
        handler();
      }
    }
    getSelectedOption() {
      return this.selectableOptions.find((option) => option.isEqualTo(this.value));
    }
    render() {
      const label = this.getSelectedOption()?.getLabel();
      return jsxs("div", { class: cls({
        [Selector.selector]: true,
        [Selector.opened]: this.isOpen,
        [Selector.noPosition]: IS_MOBILE,
        [Selector.disabled]: this.disabled
      }), onclick: this.handleClick, onkeydown: this.handleKeyDown, tabindex: "0", role: "combobox", "aria-haspopup": "listbox", "aria-expanded": this.isOpen, "aria-controls": this.uid, "aria-placeholder": this.placeholder, children: [jsx("span", { class: cls({
        [Selector.selectedOption]: true,
        "with-placeholder": !label
      }), children: label ? label : this.placeholder }), jsx("span", { class: Selector.downButton }), IS_MOBILE ? jsx(this.OptionsListMobile, {}) : jsx(this.OptionsListDesktop, {}), jsx(this.HiddenSelect, {})] });
    }
  };
  return ADWaveSelector2 = _classThis;
})();
var ADWaveSelectorOption = (() => {
  let _classDecorators = [CustomElement("adw-option")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = WcSlot;
  var ADWaveSelectorOption2 = class extends _classSuper {
    static {
      __name(this, "ADWaveSelectorOption");
    }
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      ADWaveSelectorOption2 = _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers2(_classThis, _classExtraInitializers);
    }
    get selected() {
      return this.isSelected();
    }
    set selected(selected) {
      this.setSelected(selected);
    }
    get value() {
      return this.getValue();
    }
    set value(value) {
      this.setAttribute("value", value);
    }
    get inert() {
      return this.hasAttribute("inert");
    }
    set inert(inert) {
      this.toggleAttribute("inert", inert);
    }
    constructor() {
      super();
    }
    isEqualTo(value) {
      return this.hasValue() && this.getValue() === value;
    }
    hasValue() {
      return this.hasAttribute("value");
    }
    getValue() {
      return this.getAttribute("value") ?? "";
    }
    getLabel() {
      return this.innerText;
    }
    setSelected(selected) {
      this.setAttribute("selected", selected.toString());
    }
    isSelected() {
      return this.getAttribute("selected") === "true";
    }
    shouldEmitAttributeChangeEvent(mutations) {
      for (let i = 0; i < mutations.length; i++) {
        const mutation = mutations[i];
        switch (mutation.attributeName) {
          case "inert":
          case "value":
          case "class":
            return true;
          case "selected":
            if (mutation.oldValue !== this.getAttribute("selected")) {
              return true;
            }
            break;
        }
      }
      return false;
    }
  };
  return ADWaveSelectorOption2 = _classThis;
})();

// src/utils/math.ts
function clamp(value, min, max) {
  if (min !== void 0 && value < min) {
    return min;
  }
  if (max !== void 0 && value > max) {
    return max;
  }
  return value;
}
__name(clamp, "clamp");
function toPrecision(value, precision) {
  const pow = 10 ** precision;
  const int = Math.floor(value * pow);
  return Number(int) / pow;
}
__name(toPrecision, "toPrecision");
function changeWithStep(oldValue, newValue, step) {
  const diff = newValue - oldValue;
  const stepCount = Math.round(diff / step);
  return oldValue + stepCount * step;
}
__name(changeWithStep, "changeWithStep");

// src/utils/ref.ts
var createRef = /* @__PURE__ */ __name(() => {
  return { current: null };
}, "createRef");

// src/components/slider/slider.css
var stylesheet4 = "adw-slider{display:flex;justify-content:center;align-items:center;padding-left:.3em;padding-right:.3em;touch-action:none}.skeleton adw-slider{padding-left:0;padding-right:0}";
var exports4 = {
  css: stylesheet4,
  element: null
};
(function() {
  if (typeof window !== "undefined") {
    const head = document.head;
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(stylesheet4));
    head.appendChild(style);
    exports4.element = style;
  }
})();

// src/components/slider/slider.tsx
var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers3 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var preventDefault2 = /* @__PURE__ */ __name((e) => {
  e.preventDefault();
  return false;
}, "preventDefault");
var SliderChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SliderChangeEvent");
  }
  constructor(value) {
    super("change", {
      bubbles: true,
      cancelable: true,
      detail: {
        value
      }
    });
  }
};
var ADWaveSliderElement = (() => {
  let _classDecorators = [CustomElement("adw-slider")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = BaseElement;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _min_decorators;
  let _min_initializers = [];
  let _min_extraInitializers = [];
  let _max_decorators;
  let _max_initializers = [];
  let _max_extraInitializers = [];
  let _step_decorators;
  let _step_initializers = [];
  let _step_extraInitializers = [];
  let _precision_decorators;
  let _precision_initializers = [];
  let _precision_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  let _name_decorators;
  let _name_initializers = [];
  let _name_extraInitializers = [];
  let _form_decorators;
  let _form_initializers = [];
  let _form_extraInitializers = [];
  var ADWaveSliderElement2 = class extends _classSuper {
    static {
      __name(this, "ADWaveSliderElement");
    }
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _value_decorators = [Attribute2({ type: "number", nullable: false, default: 0 })];
      _min_decorators = [Attribute2({ type: "number", nullable: false, default: 0 })];
      _max_decorators = [Attribute2({ type: "number", nullable: false, default: 100 })];
      _step_decorators = [Attribute2({ type: "number", nullable: false, default: 1 })];
      _precision_decorators = [Attribute2({ type: "number", nullable: false, default: 4 })];
      _disabled_decorators = [Attribute2({ type: "boolean", nullable: false, default: false })];
      _name_decorators = [Attribute2({ nullable: true })];
      _form_decorators = [Attribute2({ nullable: true })];
      __esDecorate3(this, null, _value_decorators, { kind: "accessor", name: "value", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "value" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.value, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.value = value;
      }, "set") }, metadata: _metadata }, _value_initializers, _value_extraInitializers);
      __esDecorate3(this, null, _min_decorators, { kind: "accessor", name: "min", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "min" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.min, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.min = value;
      }, "set") }, metadata: _metadata }, _min_initializers, _min_extraInitializers);
      __esDecorate3(this, null, _max_decorators, { kind: "accessor", name: "max", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "max" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.max, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.max = value;
      }, "set") }, metadata: _metadata }, _max_initializers, _max_extraInitializers);
      __esDecorate3(this, null, _step_decorators, { kind: "accessor", name: "step", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "step" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.step, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.step = value;
      }, "set") }, metadata: _metadata }, _step_initializers, _step_extraInitializers);
      __esDecorate3(this, null, _precision_decorators, { kind: "accessor", name: "precision", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "precision" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.precision, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.precision = value;
      }, "set") }, metadata: _metadata }, _precision_initializers, _precision_extraInitializers);
      __esDecorate3(this, null, _disabled_decorators, { kind: "accessor", name: "disabled", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "disabled" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.disabled, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.disabled = value;
      }, "set") }, metadata: _metadata }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate3(this, null, _name_decorators, { kind: "accessor", name: "name", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "name" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.name, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.name = value;
      }, "set") }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
      __esDecorate3(this, null, _form_decorators, { kind: "accessor", name: "form", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "form" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.form, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.form = value;
      }, "set") }, metadata: _metadata }, _form_initializers, _form_extraInitializers);
      __esDecorate3(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      ADWaveSliderElement2 = _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers3(_classThis, _classExtraInitializers);
    }
    #value_accessor_storage;
    get value() {
      return this.#value_accessor_storage;
    }
    set value(value) {
      this.#value_accessor_storage = value;
    }
    #min_accessor_storage;
    get min() {
      return this.#min_accessor_storage;
    }
    set min(value) {
      this.#min_accessor_storage = value;
    }
    #max_accessor_storage;
    get max() {
      return this.#max_accessor_storage;
    }
    set max(value) {
      this.#max_accessor_storage = value;
    }
    #step_accessor_storage;
    get step() {
      return this.#step_accessor_storage;
    }
    set step(value) {
      this.#step_accessor_storage = value;
    }
    #precision_accessor_storage;
    get precision() {
      return this.#precision_accessor_storage;
    }
    set precision(value) {
      this.#precision_accessor_storage = value;
    }
    #disabled_accessor_storage;
    get disabled() {
      return this.#disabled_accessor_storage;
    }
    set disabled(value) {
      this.#disabled_accessor_storage = value;
    }
    #name_accessor_storage;
    get name() {
      return this.#name_accessor_storage;
    }
    set name(value) {
      this.#name_accessor_storage = value;
    }
    #form_accessor_storage;
    get form() {
      return this.#form_accessor_storage;
    }
    set form(value) {
      this.#form_accessor_storage = value;
    }
    constructor() {
      super();
      this.#value_accessor_storage = __runInitializers3(this, _value_initializers, 0);
      this.#min_accessor_storage = (__runInitializers3(this, _value_extraInitializers), __runInitializers3(this, _min_initializers, 0));
      this.#max_accessor_storage = (__runInitializers3(this, _min_extraInitializers), __runInitializers3(this, _max_initializers, 100));
      this.#step_accessor_storage = (__runInitializers3(this, _max_extraInitializers), __runInitializers3(this, _step_initializers, 1));
      this.#precision_accessor_storage = (__runInitializers3(this, _step_extraInitializers), __runInitializers3(this, _precision_initializers, 4));
      this.#disabled_accessor_storage = (__runInitializers3(this, _precision_extraInitializers), __runInitializers3(this, _disabled_initializers, false));
      this.#name_accessor_storage = (__runInitializers3(this, _disabled_extraInitializers), __runInitializers3(this, _name_initializers, null));
      this.#form_accessor_storage = (__runInitializers3(this, _name_extraInitializers), __runInitializers3(this, _form_initializers, null));
      this.progress = (__runInitializers3(this, _form_extraInitializers), createRef());
      this.thumb = createRef();
      this.isPressed = false;
      this.handlePointerDown = (e) => {
        e.stopPropagation();
        const shouldContinue = this.dispatchEvent(new CustomPointerEvent("pointerdown", {}, e));
        if (!shouldContinue || this.disabled)
          return;
        if (e.pointerType === "mouse" && e.button !== 0)
          return;
        this.isPressed = true;
        this.handlePointerEventMove(e);
        return false;
      };
      this.handlePointerEventUp = (e) => {
        e.stopPropagation();
        this.isPressed = false;
      };
      this.handlePointerEventMove = (e) => {
        e.stopPropagation();
        if (this.disabled)
          return;
        if (this.isPressed) {
          const { left, width } = this.getBoundingClientRect();
          const percent = (e.clientX - left) / width;
          const tmpValue = changeWithStep(this.value, toPrecision(this.min + percent * (this.max - this.min), this.precision), this.step);
          this.setValue(tmpValue);
        }
      };
      this.handleKeyDown = (e) => {
        if (this.disabled)
          return;
        switch (e.key) {
          case "ArrowLeft":
            this.setValue(this.value - this.step);
            break;
          case "ArrowRight":
            this.setValue(this.value + this.step);
            break;
        }
      };
      this.effect(() => {
        if (document) {
          window.addEventListener("pointerup", this.handlePointerEventUp);
          window.addEventListener("pointermove", this.handlePointerEventMove);
        }
        return () => {
          window.removeEventListener("pointerup", this.handlePointerEventUp);
          window.removeEventListener("pointermove", this.handlePointerEventMove);
        };
      }, () => []);
      this.effect(() => {
        this.moveThumb(this.value);
      }, (s) => [s.value]);
      this.effect(({ isFirstMount }) => {
        if (isFirstMount)
          return;
        this.dispatchEvent(new SliderChangeEvent(this.value));
      }, (s) => [s.value]);
    }
    setValue(newValue) {
      const value = clamp(newValue, this.min, this.max);
      if (this.value === value)
        return;
      this.value = value;
    }
    moveThumb(value) {
      const percent = (value - this.min) / (this.max - this.min) * 100;
      this.progress.current.style.right = `${100 - percent}%`;
      this.thumb.current.style.left = `calc(${percent}% - 0.3em)`;
    }
    render() {
      return jsxs("div", { draggable: "false", class: cls({
        [Slider.slider]: true,
        [Slider.disabled]: this.disabled
      }), onpointerdown: this.handlePointerDown, onpointermove: preventDefault2, ondrag: preventDefault2, onkeydown: this.handleKeyDown, tabindex: "0", role: "slider", "aria-valuemin": this.min.toString(), "aria-valuemax": this.max.toString(), "aria-valuenow": this.value.toString(), "aria-disabled": this.disabled ? "true" : "false", children: [jsx("div", { draggable: "false", class: Slider.track, onpointermove: preventDefault2, ondrag: preventDefault2 }), jsx("div", { ref: this.progress, draggable: "false", class: Slider.progress, onpointermove: preventDefault2, ondrag: preventDefault2 }), jsx("div", { ref: this.thumb, draggable: "false", class: Slider.thumb, onpointermove: preventDefault2, ondrag: preventDefault2 }), jsx("input", { type: "range", class: "_adw_hidden", disabled: this.disabled, name: this.name ?? void 0, form: this.form ?? void 0, min: this.min, max: this.max, step: this.step.toString(), value: this.value.toString(), onchange: stopEvent, "aria-hidden": "true" })] });
    }
  };
  return ADWaveSliderElement2 = _classThis;
})();

// src/components/switch/switch.css
var stylesheet5 = "adw-switch{display:flex}";
var exports5 = {
  css: stylesheet5,
  element: null
};
(function() {
  if (typeof window !== "undefined") {
    const head = document.head;
    const style = document.createElement("style");
    style.appendChild(document.createTextNode(stylesheet5));
    head.appendChild(style);
    exports5.element = style;
  }
})();

// src/components/switch/switch.tsx
var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers4 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var SwitchChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SwitchChangeEvent");
  }
  constructor(active) {
    super("change", {
      detail: {
        active
      }
    });
  }
};
var ADWaveSwitchElement = (() => {
  let _classDecorators = [CustomElement("adw-switch")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = BaseElement;
  let _active_decorators;
  let _active_initializers = [];
  let _active_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  let _name_decorators;
  let _name_initializers = [];
  let _name_extraInitializers = [];
  let _form_decorators;
  let _form_initializers = [];
  let _form_extraInitializers = [];
  var ADWaveSwitchElement2 = class extends _classSuper {
    static {
      __name(this, "ADWaveSwitchElement");
    }
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _active_decorators = [Attribute2({ type: "boolean", nullable: false })];
      _disabled_decorators = [Attribute2({ type: "boolean", nullable: false, default: false })];
      _name_decorators = [Attribute2({ nullable: true })];
      _form_decorators = [Attribute2({ nullable: true })];
      __esDecorate4(this, null, _active_decorators, { kind: "accessor", name: "active", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "active" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.active, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.active = value;
      }, "set") }, metadata: _metadata }, _active_initializers, _active_extraInitializers);
      __esDecorate4(this, null, _disabled_decorators, { kind: "accessor", name: "disabled", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "disabled" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.disabled, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.disabled = value;
      }, "set") }, metadata: _metadata }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate4(this, null, _name_decorators, { kind: "accessor", name: "name", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "name" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.name, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.name = value;
      }, "set") }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
      __esDecorate4(this, null, _form_decorators, { kind: "accessor", name: "form", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "form" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.form, "get"), set: /* @__PURE__ */ __name((obj, value) => {
        obj.form = value;
      }, "set") }, metadata: _metadata }, _form_initializers, _form_extraInitializers);
      __esDecorate4(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      ADWaveSwitchElement2 = _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers4(_classThis, _classExtraInitializers);
    }
    #active_accessor_storage;
    get active() {
      return this.#active_accessor_storage;
    }
    set active(value) {
      this.#active_accessor_storage = value;
    }
    #disabled_accessor_storage;
    get disabled() {
      return this.#disabled_accessor_storage;
    }
    set disabled(value) {
      this.#disabled_accessor_storage = value;
    }
    #name_accessor_storage;
    get name() {
      return this.#name_accessor_storage;
    }
    set name(value) {
      this.#name_accessor_storage = value;
    }
    #form_accessor_storage;
    get form() {
      return this.#form_accessor_storage;
    }
    set form(value) {
      this.#form_accessor_storage = value;
    }
    constructor() {
      super();
      this.#active_accessor_storage = __runInitializers4(this, _active_initializers, false);
      this.#disabled_accessor_storage = (__runInitializers4(this, _active_extraInitializers), __runInitializers4(this, _disabled_initializers, false));
      this.#name_accessor_storage = (__runInitializers4(this, _disabled_extraInitializers), __runInitializers4(this, _name_initializers, null));
      this.#form_accessor_storage = (__runInitializers4(this, _name_extraInitializers), __runInitializers4(this, _form_initializers, null));
      this.handleClick = (__runInitializers4(this, _form_extraInitializers), (e) => {
        e.stopPropagation();
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {}, e));
        if (this.disabled || !shouldContinue)
          return;
        this.active = !this.active;
      });
      this.handleKeyDown = (e) => {
        e.stopPropagation();
        const shouldContinue = this.dispatchEvent(new CustomKeyboardEvent("keydown", {}, e));
        if (shouldContinue && e.key === " ") {
          if (this.disabled || !shouldContinue)
            return;
          this.active = !this.active;
        }
      };
      this.effect(({ isFirstMount }) => {
        if (isFirstMount)
          return;
        this.dispatchEvent(new SwitchChangeEvent(this.active));
      }, (s) => [s.active]);
    }
    render() {
      return jsxs("div", { class: cls({
        [Switch.switch]: true,
        [Switch.disabled]: this.disabled,
        [Switch.active]: this.active
      }), onclick: this.handleClick, onkeydown: this.handleKeyDown, tabindex: "0", role: "switch", "aria-checked": this.active, "aria-disabled": this.disabled ? "true" : "false", children: [jsx("div", { class: Switch.knob }), jsx("input", { type: "checkbox", class: "_adw_hidden", disabled: this.disabled, checked: this.active, name: this.name ?? void 0, form: this.form ?? void 0, onclick: this.handleClick, onchange: stopEvent, "aria-hidden": "true" })] });
    }
  };
  return ADWaveSwitchElement2 = _classThis;
})();
export {
  ADWaveInputElement,
  ADWaveSelector,
  ADWaveSelectorOption,
  ADWaveSliderElement,
  ADWaveSwitchElement
};
